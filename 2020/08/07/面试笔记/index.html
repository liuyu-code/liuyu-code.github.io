<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,面试,">





  <link rel="alternate" href="/atom.xml" title="远方" type="application/atom+xml">






<meta name="description" content="面试笔记一、C++1.基础知识1.1 关键字1.1.1 static 隐藏：在编译多个文件的时候，指定函数变量的作用于为文件内部，未加static具有全局可见性; 保持变量的内容持久; 默认初始化为0; C++的类成员变量会声明为static，不是对象的成员。  1.1.2 const 顶层const和底层const 对于内置类型，const相当于#define 作用：指定变量不可被当前进程、线程">
<meta name="keywords" content="C++,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试笔记">
<meta property="og:url" content="http://yoursite.com/2020/08/07/面试笔记/index.html">
<meta property="og:site_name" content="远方">
<meta property="og:description" content="面试笔记一、C++1.基础知识1.1 关键字1.1.1 static 隐藏：在编译多个文件的时候，指定函数变量的作用于为文件内部，未加static具有全局可见性; 保持变量的内容持久; 默认初始化为0; C++的类成员变量会声明为static，不是对象的成员。  1.1.2 const 顶层const和底层const 对于内置类型，const相当于#define 作用：指定变量不可被当前进程、线程">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="c:%5CUsers%5C84355%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598073194438.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180402225920837">
<meta property="og:image" content="https://pics1.baidu.com/feed/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg?token=c86d4509157378798ebbccbe843486d1&s=9746F8123F5754CA48D574DA0300D0B2">
<meta property="og:image" content="https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073">
<meta property="og:image" content="c:%5CUsers%5C84355%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598001918577.png">
<meta property="og:image" content="c:%5CUsers%5C84355%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598002280675.png">
<meta property="og:updated_time" content="2020-08-22T10:44:13.575Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试笔记">
<meta name="twitter:description" content="面试笔记一、C++1.基础知识1.1 关键字1.1.1 static 隐藏：在编译多个文件的时候，指定函数变量的作用于为文件内部，未加static具有全局可见性; 保持变量的内容持久; 默认初始化为0; C++的类成员变量会声明为static，不是对象的成员。  1.1.2 const 顶层const和底层const 对于内置类型，const相当于#define 作用：指定变量不可被当前进程、线程">
<meta name="twitter:image" content="c:%5CUsers%5C84355%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598073194438.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/07/面试笔记/">





  <title>面试笔记 | 远方</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?75a4e035c13545fa34b170e6f2c9b3cd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">远方</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">梦</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/07/面试笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lifisher">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/pic.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="远方">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-07T10:48:38+08:00">
                2020-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/08/07/面试笔记/" class="leancloud_visitors" data-flag-title="面试笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12.4k字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  45分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="面试笔记"><a href="#面试笔记" class="headerlink" title="面试笔记"></a>面试笔记</h1><h2 id="一、C"><a href="#一、C" class="headerlink" title="一、C++"></a>一、C++</h2><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h3><h4 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h4><h5 id="1-1-1-static"><a href="#1-1-1-static" class="headerlink" title="1.1.1 static"></a>1.1.1 static</h5><ul>
<li>隐藏：在编译多个文件的时候，指定函数变量的作用于为文件内部，未加static具有全局可见性;</li>
<li>保持变量的内容持久;</li>
<li>默认初始化为0;</li>
<li>C++的类成员变量会声明为static，不是对象的成员。</li>
</ul>
<h5 id="1-1-2-const"><a href="#1-1-2-const" class="headerlink" title="1.1.2 const"></a>1.1.2 const</h5><ul>
<li>顶层const和底层const</li>
<li>对于内置类型，const相当于#define</li>
<li>作用：指定变量不可被当前进程、线程修改。但可被其他线程修改。</li>
</ul>
<h5 id="1-1-3-sizeof"><a href="#1-1-3-sizeof" class="headerlink" title="1.1.3 sizeof"></a>1.1.3 sizeof</h5><p>​        计算一个数据类型的大小</p>
<h5 id="1-1-4-auto"><a href="#1-1-4-auto" class="headerlink" title="1.1.4 auto"></a>1.1.4 auto</h5><p>​        自动变量，由编译器自动分配释放，通常在栈上分配。</p>
<h5 id="1-1-5-extern"><a href="#1-1-5-extern" class="headerlink" title="1.1.5 extern"></a>1.1.5 extern</h5><p>​        作用：1.和“C”一起，告诉编译器编译函数的时候按照C的规则去翻译相应函数名；2.声明函数或者全局变量的作用范围的关键字，其声明的可以在本模块或者其他模块中使用。</p>
<h4 id="1-2-类"><a href="#1-2-类" class="headerlink" title="1.2 类"></a>1.2 类</h4><h5 id="1-2-1-创建对象的步骤？"><a href="#1-2-1-创建对象的步骤？" class="headerlink" title="1.2.1 创建对象的步骤？"></a>1.2.1 创建对象的步骤？</h5><ul>
<li>开辟空间</li>
<li>初始化对象信息</li>
<li>返回对象的地址引用</li>
</ul>
<h5 id="1-2-2-类的初始化"><a href="#1-2-2-类的初始化" class="headerlink" title="1.2.2 类的初始化"></a>1.2.2 类的初始化</h5><p>​    类的初始化顺序：只与定义有关，与初始化列表无关。若有构造函数，根据构造函数内的初始化顺序，此外const必须在构造函数内初始化，static必须在类外初始化。</p>
<h5 id="1-2-3-析构函数可以是虚函数吗？构造函数可以是虚函数吗？"><a href="#1-2-3-析构函数可以是虚函数吗？构造函数可以是虚函数吗？" class="headerlink" title="1.2.3 析构函数可以是虚函数吗？构造函数可以是虚函数吗？"></a>1.2.3 析构函数可以是虚函数吗？构造函数可以是虚函数吗？</h5><p>​    析构函数可以是虚函数，且在大部分的时候应该是虚函数，这样在进行delete运算的时候能够确保析构函数能被正确执行，可以采用动态联编的方式选择对应的析构函数。</p>
<p>​    构造函数不能为虚函数，因为在执行构造函数的时候，对象还是一片未定的空间，只有在构造完成后对象才成为一个类的实例。</p>
<h5 id="1-2-4-C-的多态是怎么实现的？"><a href="#1-2-4-C-的多态是怎么实现的？" class="headerlink" title="1.2.4 C++的多态是怎么实现的？"></a>1.2.4 C++的多态是怎么实现的？</h5><ul>
<li>编译时的多态：函数的重载</li>
<li>运行时的多态：虚函数</li>
</ul>
<h4 id="1-3-函数"><a href="#1-3-函数" class="headerlink" title="1.3 函数"></a>1.3 函数</h4><h5 id="1-3-1-参数传递"><a href="#1-3-1-参数传递" class="headerlink" title="1.3.1 参数传递"></a>1.3.1 参数传递</h5><ul>
<li>值传递：单向，形参不能改变实参，形参是实参的拷贝，形参在栈中；</li>
<li>指针传递：本质是值传递，传递的是一个地址值，函数执行的时候在栈中创建并拷贝实参的地址值，然后访问内存单元，因而可以改变主函数实参指向的变量的值。</li>
<li>引用传递：表示引用实参，即实参的一个别名，操作引用变量就是操作实参变量。在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</li>
<li>选择方式：传递类对象参数的标准方式是按引用传递。若不修改值，数据对象是较大的结构，则使用const指针或const引用，传递数组采用指针。</li>
</ul>
<h5 id="1-3-2-函数重载与函数重写的区别？"><a href="#1-3-2-函数重载与函数重写的区别？" class="headerlink" title="1.3.2 函数重载与函数重写的区别？"></a>1.3.2 函数重载与函数重写的区别？</h5><ul>
<li><p>函数重载指的是在同一可访问区被声明的几个具有不同参数列（不同参数的类型、个数和顺序）的同名函数，根据参数列表确定调用哪一个函数。（重载不关心函数的返回类型）</p>
</li>
<li><p>函数重写（覆盖，隐藏）：派生类重新定义了函数，函数的返回值，函数名以及参数列表都需要和基类中被重写的一致，只有函数体是不同的，需要有virtual修饰。</p>
</li>
<li><p>此外，C++重载是不支持函数返回类型的重载的。这是为了保持解析操作符或者函数调用的时候不依赖上下文，为了防止隐式类型转换冲突。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="comment">//这样调用的时候返回值可以通过类型转换，而不是调用的时候依赖上下文判断。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="1-3-3-内联函数"><a href="#1-3-3-内联函数" class="headerlink" title="1.3.3 内联函数"></a>1.3.3 内联函数</h5><ul>
<li>性质：内联函数在编译后不具备函数的性质，将函数体直接在编译时嵌入每一个调用处，类似宏替换，使用函数体替换调用处的函数名。此外，在类中的声明的成员函数自动转换为内联函数。内联函数不能有循环和递归。</li>
<li>优点：有类型参数检测，更加安全；在程序运行时展开，进行参数传递。如果内联函数不符合标准，会自动转为普通函数。</li>
<li>缺点：在函数调用处展开，会使代码变长，占用更多内存</li>
</ul>
<h5 id="1-3-4-宏定义函数"><a href="#1-3-4-宏定义函数" class="headerlink" title="1.3.4 宏定义函数"></a>1.3.4 宏定义函数</h5><ul>
<li>优点：使用像函数，但不是函数，使用预处理器实现，没有参数压栈，代码生成等一系列操作，因此效率很高；</li>
<li>缺点：1.仅仅是做预处理符号表中的简单替换，因此不能进行参数的有效性检测，也就不能享受C++编译器严格类型检查的好处，此外返回值也不能被强制转换为可转换的合适类型；2.宏定义不能访问类的成员变量；3.宏定义使用参数时是严格的替换策略，在展开代码中采用形参代替实参，因此容易产生二义性。</li>
</ul>
<h5 id="1-3-5-宏定义函数和内联函数的区别？"><a href="#1-3-5-宏定义函数和内联函数的区别？" class="headerlink" title="1.3.5 宏定义函数和内联函数的区别？"></a>1.3.5 宏定义函数和内联函数的区别？</h5><ul>
<li>内联函数在运行时可调试，宏定义不可以；</li>
<li>编译器会对内联函数的参数类型做安全检查或自动类型转换，而宏定义不会；</li>
<li>内联函数可以访问类的成员变量，而宏定义不行。</li>
</ul>
<h4 id="1-4-指针"><a href="#1-4-指针" class="headerlink" title="1.4 指针"></a>1.4 指针</h4><h5 id="1-4-1-智能指针"><a href="#1-4-1-智能指针" class="headerlink" title="1.4.1 智能指针"></a>1.4.1 智能指针</h5><ul>
<li>shared_ptr：维护一个计数器，采用make_shared进行分配和使用动态内存。会存在循环复用问题，采用weak_ptr可以解决。</li>
<li>unique_ptr:不支持普通的拷贝和赋值操作，但可以转移所有权。</li>
<li>auto_ptr：一种不安全的unique_ptr,C++11不建议使用。</li>
<li>weak_ptr：计数器不改变，一种弱指针，要用shared_ptr初始化，不能直接访问对象，必须调用lock判断指向的对象是否还存在，存在lock会返回一个shared_ptr。</li>
<li>线程安全：智能指针本身不是线程安全的，它的<strong>引用计数是线程安全且无锁</strong>的，但<strong>对象的读写则不是线程安全</strong>。因为shared_ptr 有两个数据成员，读写操作不能原子化。</li>
<li>注意：shared_ptr和unique_ptr必须采用直接初始化的形式。</li>
</ul>
<h5 id="1-4-2-指针和引用的区别？"><a href="#1-4-2-指针和引用的区别？" class="headerlink" title="1.4.2 指针和引用的区别？"></a>1.4.2 指针和引用的区别？</h5><ul>
<li>指针是一个对象，而引用只是对象的一个别名；</li>
<li>指针可以赋值或者拷贝，引用不可以；</li>
<li>指针可以不用初始化，但引用在使用的时候必须初始化。</li>
</ul>
<h5 id="1-4-3-delete-p和delete-p的区别？"><a href="#1-4-3-delete-p和delete-p的区别？" class="headerlink" title="1.4.3 delete p和delete[] p的区别？"></a>1.4.3 delete p和delete[] p的区别？</h5><p>​    基本类型的对象没有析构函数，所以回收基本类型组成的数组空间用 delete 和 delete[] 都是应该可以的；但是对于类对象数组，只能用 delete[]。对于 new 的单个对象，只能用 delete 不能用 delete[] 回收空间。</p>
<p>​        new []返回的地址会后移4个字节，并用那4个存放数组的大小!而new不用后移这四个字节。delete[]根据那个4个字节的值，调用指定次数的析构函数 ，同样delete也不需要那四个字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []objects; <span class="comment">// 正确的用法</span></span><br><span class="line"><span class="keyword">delete</span> objects;  <span class="comment">// 错误的用法</span></span><br></pre></td></tr></table></figure>

<p>​        后者相当于delete objects[0]，漏掉了另外99 个对象<br>​        严格应该这样说：后者相当于仅调用了objects[0]的析构函数，漏掉了调用另外99 个对象的析构函数，并且在调用之后释放内存时导致异常（如果存在析构函数的话），如果对象无析构函数该语句与delete []objects相同。</p>
<h5 id="1-4-4-new、delete和malloc、free的区别？"><a href="#1-4-4-new、delete和malloc、free的区别？" class="headerlink" title="1.4.4 new、delete和malloc、free的区别？"></a>1.4.4 new、delete和malloc、free的区别？</h5><p>​    malloc与free是C++/C的库函数,new/delete是C++的运算符，都可以用于申请动态内存和释放内存。</p>
<p>​    对于非内置类型，光有malloc和free是无法满足动态对象的要求，对象在创建的时候同时要自动执行构造函数，对象在释放的时候要自动执行析构函数，由于malloc和free是库函数，不是运算符，因此不在编译器的控制权限之内，不能把构造函数和析构函数的任务强加给malloc和free。</p>
<h5 id="1-4-5-malloc和mmap的底层实现？malloc分配的是什么？"><a href="#1-4-5-malloc和mmap的底层实现？malloc分配的是什么？" class="headerlink" title="1.4.5 malloc和mmap的底层实现？malloc分配的是什么？"></a>1.4.5 malloc和mmap的底层实现？malloc分配的是什么？</h5><p><a href="https://blog.csdn.net/weixin_41033366/article/details/105185320" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41033366/article/details/105185320</a></p>
<p><img src="C:%5CUsers%5C84355%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598073194438.png" alt="1598073194438"></p>
<p>​        Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。我们用malloc进行内存分配就是从break往上进行的。 获得了break指针的位置也就得到了堆内存申请的起始地址 malloc实际上是将可用空间用一个空闲链表连接起来，若用户申请空间，就遍历该链表，找到第一个满足条件的空闲块，将其进行拆分，返回合适大小的空间给用户，将剩下的部分链接到链表中。当调用free释放空间时，会把这块空间连接到空闲链表上。到最后，该空闲链就会被切成很多的小内存块，一旦用户申请一块较大的空间，空闲链中的空间大小都无法满足需求，malloc会申请延时，对空闲链表进行检查，内存重新整理，把相邻的小片段合并成大的空闲块。</p>
<p>​        当使用 malloc() 分配过大的空间，malloc 不再从堆中分配空间，而是使用 mmap() 这个系统调用从映射区寻找可用的内存空间。 1.当开辟的空间小于128k时，调用brk()函数，malloc的底层实现是系统调用函数brk(),其主要移动指针_enddata来开辟空间、 2.当开辟的空间大于128k时，mmap()系统调用函数来在虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空间来开辟。</p>
<h5 id="1-4-6-什么是内存泄露？"><a href="#1-4-6-什么是内存泄露？" class="headerlink" title="1.4.6 什么是内存泄露？"></a>1.4.6 什么是内存泄露？</h5><p>​    指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p>
<ul>
<li>堆内存泄露：new/malloc在申请内存使用完毕后未释放。</li>
<li>系统资源泄露：比如socket，BItmap等程序使用的系统分配的资源在使用完毕后没有使用相应的函数释放掉。</li>
</ul>
<h5 id="1-4-7-什么是野指针？"><a href="#1-4-7-什么是野指针？" class="headerlink" title="1.4.7 什么是野指针？"></a>1.4.7 什么是野指针？</h5><p>​    指向内存被释放的内存或者没有访问权限的内存的指针。</p>
<p>造成的原因：</p>
<ul>
<li>指针变量没有初始化，乱指；</li>
<li>指针p被delete或free后，没有置为NULL；</li>
<li>指针操作超越了变量的作用范围。</li>
</ul>
<h5 id="1-4-8常见的动态内存泄露？"><a href="#1-4-8常见的动态内存泄露？" class="headerlink" title="1.4.8常见的动态内存泄露？"></a>1.4.8常见的动态内存泄露？</h5><ul>
<li>1.对NULL指针解引用</li>
<li>2.对动态开辟空间进行越界访问</li>
<li>3.非动态开辟空间使用free进行释放</li>
<li>4.在使用free释放一块动态开辟的空间只释放了部分</li>
<li>5.一块空间多次释放</li>
<li>6.忘记释放—-&gt;内存泄露</li>
</ul>
<h4 id="1-5-move（）和forward（）"><a href="#1-5-move（）和forward（）" class="headerlink" title="1.5 move（）和forward（）"></a>1.5 move（）和forward（）</h4><ul>
<li>move（）：显式的将一个左值转换为对应的右值引用（绑定关系），eg. int &amp;&amp;rr3= std::move(rr1),其中rr1是一个左值。左值持久，右值短暂。</li>
<li>forward（）：</li>
</ul>
<h4 id="1-6-左值引用和右值引用"><a href="#1-6-左值引用和右值引用" class="headerlink" title="1.6 左值引用和右值引用"></a>1.6 左值引用和右值引用</h4><h5 id="1-6-1-左值和右值的区分？"><a href="#1-6-1-左值和右值的区分？" class="headerlink" title="1.6.1 左值和右值的区分？"></a>1.6.1 左值和右值的区分？</h5><ul>
<li>C++中可以取地址有名字的就是左值；反之不能取地址的没有名字的就是右值（将忘值或者纯右值）。</li>
<li>左右值都属于引用类型，因此需要初始化，左值是具有变量值的别名，右值是不具有变量名的别名，左值通常不能绑定到右值（例外：const int&amp; b=2是对的，不加const是错的），右值也通常不能绑定到任何左值（但采用std::move()可以将左值强制转换为右值）。</li>
</ul>
<h5 id="1-6-2-为什么要进行右值引用？"><a href="#1-6-2-为什么要进行右值引用？" class="headerlink" title="1.6.2 为什么要进行右值引用？"></a>1.6.2 为什么要进行右值引用？</h5><p>​    当程序猿需要使用寄存器的值的时候是可以进行右值引用的，寄存器的刷新速度很快，没有右值引用的话就需要先将寄存器的值拷贝到内存中，再进行使用，这样很浪费空间，效率也不高。</p>
<h4 id="1-7-union"><a href="#1-7-union" class="headerlink" title="1.7 union"></a>1.7 union</h4><h5 id="1-7-1-什么是union？"><a href="#1-7-1-什么是union？" class="headerlink" title="1.7.1 什么是union？"></a>1.7.1 什么是union？</h5><p>​    一种特殊的类，可以在里面定义多个不同的数据类型。这些数据共享内存，可以节省空间。</p>
<h5 id="1-7-2-union和struct区别？"><a href="#1-7-2-union和struct区别？" class="headerlink" title="1.7.2 union和struct区别？"></a>1.7.2 union和struct区别？</h5><ul>
<li>struct里面成员各自有自己的内存空间；</li>
<li>union中共享内存空间，大小为各成员中最长的长度。</li>
</ul>
<h5 id="1-7-3-union需要注意的？"><a href="#1-7-3-union需要注意的？" class="headerlink" title="1.7.3 union需要注意的？"></a>1.7.3 union需要注意的？</h5><p>​    不能继承，也不能作为基类，所以无虚函数。类不可以放入union中，此外由于联合里面的内容共享内存，所以也不能够放引用和静态。</p>
<h4 id="1-8-强制转换"><a href="#1-8-强制转换" class="headerlink" title="1.8 强制转换"></a>1.8 强制转换</h4><ul>
<li>static_cast：用于非多态类型转换(静态转换)，任何标准转换都可以用它，但是不能用于两个不相关的类型转换。</li>
<li>dynamic_cast：用于将一个父类对象的指针转换为子类对象的指针或引用，只能用于有虚函数的类（必须有共有继承和虚函数）。（动态交换）<ul>
<li>向上转型：子类对象指针–&gt;父类对象指针/引用（不需要转化）</li>
<li>向下转型：父类对象指针–&gt;子类对象指针/引用（用dynamic_cast转型是安全的）</li>
</ul>
</li>
<li>const_cast：删除变量const的属性，方便赋值</li>
<li>reinterpret_cast：将一种类型转换为另一种不同的类型。</li>
</ul>
<h3 id="2-容器类库"><a href="#2-容器类库" class="headerlink" title="2.容器类库"></a>2.容器类库</h3><ul>
<li>vector</li>
<li>list</li>
<li>deque</li>
<li>queue</li>
<li>stack</li>
<li>set、multiset</li>
<li>map、multimap</li>
</ul>
<h3 id="3-线程库"><a href="#3-线程库" class="headerlink" title="3.线程库"></a>3.线程库</h3><p>3.1 thread</p>
<p>3.2 condition_variable</p>
<p>3.3 mutex</p>
<h3 id="4-内存管理（堆栈管理）"><a href="#4-内存管理（堆栈管理）" class="headerlink" title="4.内存管理（堆栈管理）"></a>4.内存管理（堆栈管理）</h3><h4 id="4-1堆栈的区别？"><a href="#4-1堆栈的区别？" class="headerlink" title="4.1堆栈的区别？"></a>4.1堆栈的区别？</h4><ul>
<li>管理方式：堆是程序员管理，栈属于编译器管理；</li>
<li>空间大小：堆的空间大，栈的空间小；</li>
<li>是否产生碎片：堆会产生碎片，栈不会产生碎片</li>
<li>生长方式不同：堆是向内存大的方向生长，栈是向内存小的方向生长</li>
<li>分配方式：堆一般是动态分配的，栈是静态分配；</li>
<li>分配效率：堆的分配效率低，栈的分配效率高。</li>
</ul>
<h3 id="5-C-编译成可执行程序的过程"><a href="#5-C-编译成可执行程序的过程" class="headerlink" title="5.C++编译成可执行程序的过程"></a>5.C++编译成可执行程序的过程</h3><p>过程如下：</p>
<p>（一）预处理阶段。首先我们会对我们编辑得到的源代码（即扩展名为.c/.cpp文件）通过预处理器进行预处理，这一部分是由我们的编译器帮我们完成的。预处理器做的事情就是将原始源文件中的所有预处理器指令替换为暗示指令的实际库代码。那么什么是预处理指令呢？实际上这些是我们在代码很常见的，如#include和#define指令。之后，生成的文件基本上被取代并获得扩展名为.i文件。</p>
<p>（二）编译器编译阶段。接下来是编译器的处理阶段，这个阶段是把高级语言翻译成低级语言的过程，也负责检查源代码的语法/语法。若发现无误，则会将文件转换为扩展名为.s的文件，即我们所知的汇编代码。</p>
<p>（三）目标文件转换阶段。得到汇编文件之后，要对其进行转换，即该过程是将汇编级语言转换为机器级语言（一般为二进制格式），此时生成的文件就是我们的目标文件，扩展名为.o或.obj。</p>
<p>（四）链接阶段。C++语言支持分离式编译（这里指的编译是指上面（一）至（三）阶段）机制的，该机制允许将程序分割为若干个文件，每个文件可独立编译。那么多个已编译的文件如何合并呢？答案就是在此阶段。该阶段通过链接器将一个或多个目标文件合并到一个可执行文件，即将扩展名为.obj / .o文件转换为扩展名为.exe文件。</p>
<p>注：我们平常所说的“编译”是一个整体，即包括预处理，编译和汇编三个阶段。它在这些步骤中基本上将高级语言转换为机器级语言，并生成单个二进制对象文件。若编译（但不链接）三个单独的文件，则将创建三个作为输出的目标文件。在运行程序前（未加载到内存），可执行程序已经分为code，data，bbs区（未初始化数据区),运行后增加了堆区和栈区。</p>
<p><img src="https://img-blog.csdn.net/20180402225920837" alt="pic"></p>
<h3 id="6-C-11的新特性有哪些？"><a href="#6-C-11的新特性有哪些？" class="headerlink" title="6.C++11的新特性有哪些？"></a>6.C++11的新特性有哪些？</h3><ul>
<li><p>类型说明符：auto用于从初始化表达式中推断出变量的数据类型。因此，auto<strong>定义的变量必须有初始值。</strong></p>
</li>
<li><p>类型说明符：decltype：选择并返回操作数的数据类型。编译器会分析表达式并得到它的类型，但是不会去计算表达式的值。</p>
<p>注意：如果decltype使用的是一个不加括号的变量，得到的就是该变量的类型。如果给变量加上了一层括号，编译器会把它当作一个表达式，得到的则是引用类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) a; <span class="comment">//a的类型是int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) b=i; <span class="comment">//b的类型是&amp;int，必须对其初始化，否则编译错误。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>空指针：nullptr：为了解决原来NULL的二义性，原来的NULL就是0；</p>
</li>
<li><p>基于范围的for循环</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;point&gt; ps(<span class="number">10</span>,x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : ps)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i.x &lt;&lt; <span class="string">" "</span>&lt;&lt;i.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>虚函数的override和final指示符：</p>
<ul>
<li>override，表示派生类应当重写基类中的虚函数</li>
<li>final，表示派生类不应当重写这个虚函数</li>
</ul>
</li>
<li><p>constexpr变量：将变量声明为constexpr类型以便由编译器来验证变量的值是否为一个常量表达式，必须在编译期间计算出它的值并且它的值不可以被改变</p>
</li>
<li><p>noexcept：声明一个函数不可以抛出任何异常使用关键字noexcept；</p>
</li>
<li><p>匿名函数（Lambda函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] (<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></span><br><span class="line">[] (<span class="keyword">int</span>&amp; x) &#123; ++x;  &#125; <span class="comment">// 没有 return 语句 -&gt; Lambda 函数的返回类型是 'void'</span></span><br><span class="line">[] () &#123; ++global_x;  &#125; <span class="comment">// 没有参数，仅访问某个全局变量</span></span><br><span class="line">[] &#123; ++global_x; &#125; <span class="comment">// 与上一个相同，省略了 (操作符重载函数参数)</span></span><br></pre></td></tr></table></figure>





</li>
</ul>
<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="1-链表"><a href="#1-链表" class="headerlink" title="1.链表"></a>1.链表</h3><h4 id="1-1-有环链表"><a href="#1-1-有环链表" class="headerlink" title="1.1 有环链表"></a>1.1 有环链表</h4><h4 id="1-2-链表的插入和删除"><a href="#1-2-链表的插入和删除" class="headerlink" title="1.2 链表的插入和删除"></a>1.2 链表的插入和删除</h4><h4 id="1-3-链表的逆序"><a href="#1-3-链表的逆序" class="headerlink" title="1.3 链表的逆序"></a>1.3 链表的逆序</h4><h4 id="1-4-链表的深复制"><a href="#1-4-链表的深复制" class="headerlink" title="1.4 链表的深复制"></a>1.4 链表的深复制</h4><h3 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2.二叉树"></a>2.二叉树</h3><h4 id="2-1完全二叉树的存储"><a href="#2-1完全二叉树的存储" class="headerlink" title="2.1完全二叉树的存储"></a>2.1完全二叉树的存储</h4><h4 id="2-2-哈夫曼树"><a href="#2-2-哈夫曼树" class="headerlink" title="2.2 哈夫曼树"></a>2.2 哈夫曼树</h4><h4 id="2-3-满二叉树"><a href="#2-3-满二叉树" class="headerlink" title="2.3 满二叉树"></a>2.3 满二叉树</h4><h4 id="2-4-树的前序遍历"><a href="#2-4-树的前序遍历" class="headerlink" title="2.4 树的前序遍历"></a>2.4 树的前序遍历</h4><h4 id="2-5-树的中序遍历"><a href="#2-5-树的中序遍历" class="headerlink" title="2.5 树的中序遍历"></a>2.5 树的中序遍历</h4><h4 id="2-6-树的后序遍历"><a href="#2-6-树的后序遍历" class="headerlink" title="2.6 树的后序遍历"></a>2.6 树的后序遍历</h4><h4 id="2-7-树的层序遍历"><a href="#2-7-树的层序遍历" class="headerlink" title="2.7 树的层序遍历"></a>2.7 树的层序遍历</h4><h4 id="2-8-树的深度和广度"><a href="#2-8-树的深度和广度" class="headerlink" title="2.8 树的深度和广度"></a>2.8 树的深度和广度</h4><h4 id="2-9-红黑树"><a href="#2-9-红黑树" class="headerlink" title="2.9 红黑树"></a>2.9 红黑树</h4><p>​    红黑树的使用有两种特点：1.key/value快速查找；2.RBtree的顺序，来查找一段。</p>
<p>​    epoll、内存管理、map、进程的调度都用到了红黑树。进程中有一个就绪队列，可以通过vruntime当做key组织成一个红黑树，比当前时间小的都拿出来进行执行。</p>
<h3 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h3><h4 id="3-1-哈希表怎么解决冲突？"><a href="#3-1-哈希表怎么解决冲突？" class="headerlink" title="3.1 哈希表怎么解决冲突？"></a>3.1 哈希表怎么解决冲突？</h4><p>​    再hash法，链地址法，建立公共溢出区</p>
<h3 id="4-图"><a href="#4-图" class="headerlink" title="4.图"></a>4.图</h3><h4 id="4-1最小生成树算法"><a href="#4-1最小生成树算法" class="headerlink" title="4.1最小生成树算法"></a>4.1最小生成树算法</h4><ul>
<li>prim算法</li>
<li>克鲁斯卡尔算法</li>
</ul>
<h4 id="4-2-最短路径算法"><a href="#4-2-最短路径算法" class="headerlink" title="4.2 最短路径算法"></a>4.2 最短路径算法</h4><ul>
<li>迪杰斯特拉算法</li>
<li>Floyd算法</li>
</ul>
<h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><h3 id="1-常用的算法"><a href="#1-常用的算法" class="headerlink" title="1.常用的算法"></a>1.常用的算法</h3><p>单调栈，双指针，滑动窗口，动态规划，贪心法，分治法，减治法，回溯法，位运算，蛮力法；</p>
<h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><p>2.1常见排序：归并排序，快速排序，堆排序，冒泡排序，选择排序，直接插入排序，计数排序。</p>
<h3 id="3-递归"><a href="#3-递归" class="headerlink" title="3.递归"></a>3.递归</h3><p>3.1递归的本质是一个栈</p>
<h3 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4.时间复杂度分析"></a>4.时间复杂度分析</h3><h2 id="四、设计模式"><a href="#四、设计模式" class="headerlink" title="四、设计模式"></a>四、设计模式</h2><h3 id="1-常见的设计模式"><a href="#1-常见的设计模式" class="headerlink" title="1.常见的设计模式"></a>1.常见的设计模式</h3><ul>
<li>创建型模式：单例模式，工厂模式</li>
<li>结构型模式：适配器模式，装饰器模式</li>
<li>行为性模式：观察者模式、模板模式</li>
</ul>
<h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>懒汉模式（线程不安全）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>)</span><br><span class="line">            instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::instance=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>饿汉模式(线程安全)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::instance=<span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure>

<p>懒汉模式（线程安全，加锁）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    <span class="keyword">static</span> mutex m;</span><br><span class="line">    Singleton()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;mutex&gt; lock(m);</span><br><span class="line">            <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::instance=<span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton::m;</span><br></pre></td></tr></table></figure>

<h3 id="3-观察者模式"><a href="#3-观察者模式" class="headerlink" title="3.观察者模式"></a>3.观察者模式</h3><p>​    项目中出现的观察者模式：ROS中的topic。vue中的v-module。观察者模式通常被用来实时事件处理系统。</p>
<h2 id="五、数据库（MySQL）"><a href="#五、数据库（MySQL）" class="headerlink" title="五、数据库（MySQL）"></a>五、数据库（MySQL）</h2><h3 id="1-mysql特点"><a href="#1-mysql特点" class="headerlink" title="1.mysql特点"></a>1.mysql特点</h3><p>​        插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。</p>
<h3 id="2-mysql的框架"><a href="#2-mysql的框架" class="headerlink" title="2.mysql的框架"></a>2.mysql的框架</h3><p>​        连接层，服务层，数据存储引擎层，文件系统（存储层）</p>
<h3 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h3><h4 id="3-1-ACID特性"><a href="#3-1-ACID特性" class="headerlink" title="3.1 ACID特性"></a>3.1 ACID特性</h4><ul>
<li>原子性：一个事务要么全都执行，要么全部不执行；</li>
<li>一致性：一个事物提交前后数据库应该是保持一致的。</li>
<li>隔离性：事务之间是互相不影响的，一个事务的执行不能被其他事务干扰。</li>
<li>持久性：事务一旦提交对数据库的修改就是永久性的。</li>
</ul>
<h4 id="3-2-事务的安全性问题"><a href="#3-2-事务的安全性问题" class="headerlink" title="3.2 事务的安全性问题"></a>3.2 事务的安全性问题</h4><ul>
<li>脏读：读取了已经更新但未提交的数据（可能撤销了更新），脏读是事务B修改了数据。</li>
<li>不可重复读：在脏读后撤销操作再次读取，发现两次读的内容不一样，A读取了B已经提交的修改数据。</li>
<li>幻读：针对的插入和删除，两次读取结果不一样，幻读是事务B新增了数据。</li>
</ul>
<h4 id="3-3-事务的隔离级别"><a href="#3-3-事务的隔离级别" class="headerlink" title="3.3 事务的隔离级别"></a>3.3 事务的隔离级别</h4><ul>
<li>读未提交：三种问题都会出现（脏读、不可重复读、幻读）</li>
<li>读已提交（Oracle）：可以避免脏读，但不可避免另外两种。</li>
<li>可重复读（MySQL）：不可解决幻读，可解决另外两个。</li>
<li>可序列化：可解决所有问题（相当于加锁等待），但性能低下。</li>
</ul>
<h3 id="4-存储引擎"><a href="#4-存储引擎" class="headerlink" title="4.存储引擎"></a>4.存储引擎</h3><h4 id="4-1-InnoDB"><a href="#4-1-InnoDB" class="headerlink" title="4.1 InnoDB"></a>4.1 InnoDB</h4><p>​        支持事务、主外键、行锁（适合高并发），不仅缓存索引，还缓存真实数据，对内存要求较高，而且内存大小对性能有决定性影响。表空间大，主要关注点为事务。</p>
<h4 id="4-2-MyISAM"><a href="#4-2-MyISAM" class="headerlink" title="4.2 MyISAM"></a>4.2 MyISAM</h4><p>​        不支持主外键和事务，采用表锁（操作一条记录会锁住整个表），只缓存索引，不缓存真实数据，表空间小，关注点为性能。</p>
<h3 id="5-索引"><a href="#5-索引" class="headerlink" title="5.索引"></a>5.索引</h3><h4 id="5-1索引的定义"><a href="#5-1索引的定义" class="headerlink" title="5.1索引的定义"></a><strong>5.1索引的定义</strong></h4><p>​    索引是帮助MYSQL高效获取数据的数据结构。提高查询效率，类比字典，排好序的快速查找数据结构。索引一般都很大，不可能全部存在内存中，因此会以索引文件存储在磁盘上。</p>
<h4 id="5-2-索引的分类（方法）"><a href="#5-2-索引的分类（方法）" class="headerlink" title="5.2 索引的分类（方法）"></a><strong>5.2 索引的分类（方法）</strong></h4><ul>
<li>全文索引：只有MyISAM支持，为了解决针对文本的模糊查询效率较低的问题；</li>
<li>HASH索引：一次定位，针对‘=’和‘in’有极高的效率,但范围查询，排序等效率仍然不高；</li>
<li>BTree：MYSQL默认和最常用的索引；</li>
<li>RTree：在mysql中少，优势在于范围查找。</li>
</ul>
<h4 id="5-3-索引的分类"><a href="#5-3-索引的分类" class="headerlink" title="5.3 索引的分类"></a><strong>5.3 索引的分类</strong></h4><ul>
<li>单一索引</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>复合索引：在使用的时候将条件顺序按照索引的顺序，否则索引失效。遵循的是<strong>最左原则</strong>，创建复合索引的规则是先对最左边字段进行排序，在第一个完成排序的基础上再对第二个字段进行排序，第一个字段绝对有序，而第二个字段就是无序的。</li>
<li>文本索引</li>
</ul>
<h4 id="5-4-索引的优势和劣势"><a href="#5-4-索引的优势和劣势" class="headerlink" title="5.4 索引的优势和劣势"></a><strong>5.4 索引的优势和劣势</strong></h4><ul>
<li>优势：查询快，排序快</li>
<li>劣势：更新表速度慢，占用空间变大</li>
</ul>
<h4 id="5-5-B树和B-树"><a href="#5-5-B树和B-树" class="headerlink" title="5.5 B树和B+树"></a><strong>5.5 B树和B+树</strong></h4><ul>
<li>B树：非叶子节点也有数据，效率比B+树高</li>
<li>B+树（MySQL采用的）：只有叶子节点有数据。B+树的优势是IO少，在设备内存一定的情况下，B+树更好；此外连续读取的时候只需要访问叶子节点。</li>
</ul>
<h4 id="5-6-聚簇索引和非聚簇索引"><a href="#5-6-聚簇索引和非聚簇索引" class="headerlink" title="5.6 聚簇索引和非聚簇索引"></a><strong>5.6 聚簇索引和非聚簇索引</strong></h4><p>​    除了主键索引其他都是非聚簇索引，在空间上不连续，不是主顺序</p>
<h3 id="6-锁"><a href="#6-锁" class="headerlink" title="6.锁"></a>6.锁</h3><h4 id="6-1锁粒度"><a href="#6-1锁粒度" class="headerlink" title="6.1锁粒度"></a>6.1锁粒度</h4><ul>
<li>表级锁：偏向MyISAM引擎，开销小，加锁快，粒度大，冲突高。</li>
<li>行级锁：偏向InNoDB，开销大，加锁慢，会出现死锁，锁定粒度最小，发生冲突概率最低，并发度最高，支持事务。（无索引或索引失效行锁会升级为表锁），锁定一行（select…for update）。</li>
<li>使用行级锁产生间隙锁：产生危害，采用范围条件加锁，没有这一项也会被锁住。</li>
</ul>
<h4 id="6-2-锁级别"><a href="#6-2-锁级别" class="headerlink" title="6.2 锁级别"></a>6.2 锁级别</h4><ul>
<li>共享锁（读锁）：当前用户锁后，其他用户可以查询但写会阻塞，当前用户也不可以写，也不能读其他表。</li>
<li>排它锁（写锁）：当前用户加锁后增删改查都可以，但其他用户所有操作被阻塞。</li>
<li>区别：读锁会阻塞写，写锁会把读和写都阻塞</li>
</ul>
<h4 id="6-3-乐观锁和悲观锁"><a href="#6-3-乐观锁和悲观锁" class="headerlink" title="6.3 乐观锁和悲观锁"></a>6.3 乐观锁和悲观锁</h4><ul>
<li>悲观锁：有共享锁和排它锁，在数据处理的整个过程中将数据处于锁定状态</li>
<li>乐观锁：假定不会出现冲突，如果在提交更新的时候出现冲突，则返回错误信息让用户选择如何解决，一般实现方式就是记录数据版本。并未加锁，效率高，但掌握不好更新失败的概率会很高。</li>
</ul>
<h3 id="7-视图"><a href="#7-视图" class="headerlink" title="7.视图"></a>7.视图</h3><h4 id="7-1视图"><a href="#7-1视图" class="headerlink" title="7.1视图"></a>7.1视图</h4><p>​        一个虚拟表，临时性，和普通表一样使用；动态生成，只保存了sql逻辑，不保存结果。</p>
<h2 id="六、操作系统"><a href="#六、操作系统" class="headerlink" title="六、操作系统"></a>六、操作系统</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><h4 id="1-1进程"><a href="#1-1进程" class="headerlink" title="1.1进程"></a>1.1进程</h4><h5 id="1-1-1-进程的通信方式"><a href="#1-1-1-进程的通信方式" class="headerlink" title="1.1.1 .进程的通信方式"></a><strong>1.1.1 .进程的通信方式</strong></h5><ul>
<li>信号量：用于进程之间互斥和同步，实质是计数器</li>
<li>管道：半双工，亲缘关系</li>
<li>有名管道：一种文件类型，半双工，可无亲缘关系，以一种特殊文件形式存在于文件系统中。</li>
<li>共享内存：最快的方式，进程直接对内存进行读取，常与信号量结合使用，方便同步。</li>
<li>消息队列：有优先级和特定格式，独立于接收和发送线程</li>
<li>socket</li>
</ul>
<h5 id="1-1-2-进程的定义与特点"><a href="#1-1-2-进程的定义与特点" class="headerlink" title="1.1.2.进程的定义与特点"></a><strong>1.1.2.进程的定义与特点</strong></h5><p>​    进程是资源分配和拥有的基本单位。进程是一个实体，有自己地址空间，比如CODE、DATA、堆栈区；进程是一个正在执行中的程序。</p>
<h5 id="1-1-3-进程（作业）的调度算法"><a href="#1-1-3-进程（作业）的调度算法" class="headerlink" title="1.1.3 .进程（作业）的调度算法"></a><strong>1.1.3 .进程（作业）的调度算法</strong></h5><ul>
<li>FCFS（先来先服务）</li>
<li>SJF（最短作业优先）</li>
<li>HRN（最高响应比优先）：R=(W+T)/T=1+W/T (W为等待时间，即当前时间减去到达时间，T为执行时间）</li>
</ul>
<h5 id="1-1-4-进程拥有的资源"><a href="#1-1-4-进程拥有的资源" class="headerlink" title="1.1.4 .进程拥有的资源"></a><strong>1.1.4 .进程拥有的资源</strong></h5><p>​    系统资源，打开的文件fd，地址空间</p>
<h4 id="1-2线程"><a href="#1-2线程" class="headerlink" title="1.2线程"></a>1.2线程</h4><h5 id="1-2-1-线程同步的方式？"><a href="#1-2-1-线程同步的方式？" class="headerlink" title="1.2.1.线程同步的方式？"></a>1.2.1.线程同步的方式？</h5><p>C++：互斥量（mutex)、条件变量（condition_variable）、读写锁、条件变量</p>
<h5 id="1-2-2-线程拥有的资源？"><a href="#1-2-2-线程拥有的资源？" class="headerlink" title="1.2.2.线程拥有的资源？"></a>1.2.2.线程拥有的资源？</h5><ul>
<li>共享资源：和其他线程共享进程拥有的全部资源，包括代码段，共有数据等，自己基本上不拥有系统资源</li>
<li>独有的资源：程序计数器，一组寄存器和堆栈，线程的优先级等。</li>
</ul>
<h5 id="1-2-3-线程的状态？"><a href="#1-2-3-线程的状态？" class="headerlink" title="1.2.3.线程的状态？"></a>1.2.3.线程的状态？</h5><p>​    就绪、阻塞、运行</p>
<h4 id="1-3进程与线程的区别？"><a href="#1-3进程与线程的区别？" class="headerlink" title="1.3进程与线程的区别？"></a>1.3进程与线程的区别？</h4><p>​    地址空间：多进程中每个进程有自己的地址空间，线程则是共享地址空间；</p>
<p>​    定义：前者是资源分配和拥有的基本单位，而后者只是共享进程的资源；线程是处理器调度的基本单位，但进程不是；</p>
<p>​    执行：线程不能够独立执行，必须依存在应用程序中；</p>
<p>​    速度：线程的速度更快，通讯快，切换快，线程资源利用率好。</p>
<h3 id="2-IO多路复用"><a href="#2-IO多路复用" class="headerlink" title="2.IO多路复用"></a>2.IO多路复用</h3><p>参见blog：<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></p>
<h4 id="2-1-一次IO操作流程"><a href="#2-1-一次IO操作流程" class="headerlink" title="2.1 一次IO操作流程"></a>2.1 一次IO操作流程</h4><p>​    一次IO，数据首先会被拷贝到内核的缓冲区，然后从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<ul>
<li>等待数据准备，进入内核的缓冲区；</li>
<li>从内核的缓冲区将数据拷贝到进程中。</li>
</ul>
<h4 id="2-2-同步IO"><a href="#2-2-同步IO" class="headerlink" title="2.2 同步IO"></a>2.2 同步IO</h4><ul>
<li>阻塞IO：在IO的两个阶段都被阻塞，需要等待数据准备，比如默认socket通信；</li>
<li>非阻塞IO：当用户进行read操作的时候，内核数据没有准备好，会返回一个error，用户进程不会被阻塞，这样用户进程可以一直询问，一旦内核的数据准备好，并且收到了用户进程的system call，内核立马准备将数据拷贝到用户进程内存中。（特点：用户进程不断主动询问内核数据是否数据已经准备好）</li>
<li>IO多路复用：同时处理多个网络连接的IO，采用select、poll、epoll这几种方式不断轮询所负责的所有socket，当某个socket有数据到达的时候，通知用户进程。</li>
</ul>
<h4 id="2-3-异步IO（使用较少）"><a href="#2-3-异步IO（使用较少）" class="headerlink" title="2.3 异步IO（使用较少）"></a>2.3 异步IO（使用较少）</h4><p>​    用户在发出read后，立马可以做其他的事情，当kernel接收到异步read后，首先会立刻返回，所以用户进程不会被block，然后kernel会等待数据准备完成，然后将数据拷贝到用户内存。只有当这两个步骤都完成了，kernel会给用户进程发送一个signal，告诉它完成了read。</p>
<h4 id="2-4-同步IO和异步IO的区别"><a href="#2-4-同步IO和异步IO的区别" class="headerlink" title="2.4 同步IO和异步IO的区别"></a>2.4 同步IO和异步IO的区别</h4><p>​    同步IO在进行真实的IO操作（两步）的时候进程会被阻塞（其中非阻塞IO会在kernel将数据从内核拷贝到内存的时候被阻塞了），因此前几种都属于同步IO，而异步IO值的是内核在数据准备好后，还自己完成了读写，当两个步骤都完成了之后才会告诉用户进程。</p>
<h4 id="2-5-阻塞IO和非阻塞IO的区别"><a href="#2-5-阻塞IO和非阻塞IO的区别" class="headerlink" title="2.5 阻塞IO和非阻塞IO的区别"></a>2.5 阻塞IO和非阻塞IO的区别</h4><p>​    阻塞IO会一直阻塞对应的进程直到操作完成，而非阻塞IO在内核还在准备数据的情况下回立即返回。</p>
<h4 id="2-6-IO多路复用（事件驱动IO）"><a href="#2-6-IO多路复用（事件驱动IO）" class="headerlink" title="2.6 IO多路复用（事件驱动IO）"></a>2.6 IO多路复用（事件驱动IO）</h4><p>​        特点：通过一种机制一个进程就能同时等待多个文件描述符（fd），而这些fd其中任意一个进入读就绪状态，select（）函数就可以返回。</p>
<p>​        select、poll、epoll本质上都是同步IO，因为都需要在读写事件就绪后自己负责读写，也就是读写这个过程仍然是阻塞的。</p>
<h5 id="2-6-1-select（）和-poll（）"><a href="#2-6-1-select（）和-poll（）" class="headerlink" title="2.6.1 select（）和 poll（）"></a>2.6.1 select（）和 poll（）</h5><p>​        select和poll都需要在返回后遍历文件描述符来获取已经就绪的socket,描述符越多效率越低,两者异同为：</p>
<ol>
<li>select有最大数量限制（linux：1024）,poll没有,但是数量过大都会影响性能(遍历文件描述符)</li>
<li>select使用3个位图表示三种文件描述符,poll使用一个pollfd的指针实现。</li>
</ol>
<h5 id="2-6-3-epoll（）"><a href="#2-6-3-epoll（）" class="headerlink" title="2.6.3 epoll（）"></a>2.6.3 epoll（）</h5><p>​        epoll是select和poll的增强版,epoll通过epoll_ctl()来注册一个文件描述符,一旦基于某个文件描述符就绪时,内核会采用类似callback的回调机制,迅速激活这个文件描述符,当进程调用epoll_wait()时便得到通知(不再需要遍历文件描述符,通过监听回调的机制,也是epoll的魅力)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，并没有限制，只是一个参考。</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="comment">//- epfd：是epoll_create()的返回值。</span></span><br><span class="line"><span class="comment">//- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span></span><br><span class="line"><span class="comment">//- fd：是需要监听的fd（文件描述符）</span></span><br><span class="line"><span class="comment">//- epoll_event：是告诉内核需要监听什么事</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">//等待epfd上的io事件，最多返回maxevents个事件。参数events用来从内核得到事件的集合.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>工作模式<ul>
<li><strong>LT（水平触发，默认）</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li><strong>ET（边缘触发）</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。效率相对更高。</li>
</ul>
</li>
</ul>
<h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3.内存管理"></a>3.内存管理</h3><h4 id="3-1内存管理的方式"><a href="#3-1内存管理的方式" class="headerlink" title="3.1内存管理的方式"></a>3.1内存管理的方式</h4><h4 id="3-2linux内存管理"><a href="#3-2linux内存管理" class="headerlink" title="3.2linux内存管理"></a>3.2linux内存管理</h4><p>​    linux采用的是请求调页的方式进行内存管理</p>
<h4 id="3-3-虚拟内存、常驻内存、共享内存"><a href="#3-3-虚拟内存、常驻内存、共享内存" class="headerlink" title="3.3 虚拟内存、常驻内存、共享内存"></a>3.3 虚拟内存、常驻内存、共享内存</h4><ul>
<li>VIRT:</li>
<li>RES:</li>
<li>SHARE:</li>
</ul>
<h3 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h3><p>4.1死锁产生的条件</p>
<ul>
<li>互斥条件</li>
<li>部分分配</li>
<li>不可剥夺条件</li>
<li>环路条件</li>
</ul>
<p>4.2死锁的解决办法</p>
<p>​    死锁可以预防、避免、检测和解除。死锁预防直接打破四个产生的条件之一即可（但都不合适）。死锁避免采用银行家算法。死锁解除：可以杀掉所有进程或争夺临界变量的进程。</p>
<h3 id="5-生产者消费者模型"><a href="#5-生产者消费者模型" class="headerlink" title="5.生产者消费者模型"></a>5.生产者消费者模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> threadNum 2</span></span><br><span class="line">condition_variable produce,consume;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">500</span>);</span><br><span class="line">        unique_lock&lt;mutex&gt; lock(m);</span><br><span class="line">        <span class="keyword">while</span>(q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            consume.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"consume:"</span>&lt;&lt;temp&lt;&lt; <span class="string">" size:"</span>&lt;&lt;q.size()&lt;<span class="built_in">endl</span>;</span><br><span class="line">        produce.notify_all();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">        unique_lock&lt;mutex&gt; lock(m);</span><br><span class="line">        <span class="keyword">while</span>(q.size() == MAXSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            produce.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(i);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"produce: "</span>&lt;&lt;i&lt;&lt;<span class="string">" size:"</span>&lt;&lt;q.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        consume.notify_all();</span><br><span class="line">        lock.unlock():</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	thread p[threadNum], c[threadNum];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = thread(producer, i);</span><br><span class="line">		c[i] = thread(consumer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i].join();</span><br><span class="line">		c[i].join();</span><br><span class="line">	&#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、计算机网络"><a href="#七、计算机网络" class="headerlink" title="七、计算机网络"></a>七、计算机网络</h2><h3 id="1-七层、五层、四层网络模型"><a href="#1-七层、五层、四层网络模型" class="headerlink" title="1.七层、五层、四层网络模型"></a>1.七层、五层、四层网络模型</h3><p>五层协议：</p>
<ul>
<li>应用层：HTTP，FTP，TFTP，SMTP，DNS，Telnet</li>
<li>传输层：TCP、UDP</li>
<li>网络层：IP，ICMP，IGMP，RIP，ARP，RARP</li>
<li>数据链路层：CSMA/CD</li>
<li>物理层：IEEE802.2</li>
</ul>
<p>七层协议：</p>
<ul>
<li>应用层：FTP、HTTP</li>
<li>表示层：Telnet</li>
<li>会话层：SMTP，DNS</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h3 id="2-TCP-IP协议"><a href="#2-TCP-IP协议" class="headerlink" title="2.TCP/IP协议"></a>2.TCP/IP协议</h3><p><a href="https://juejin.im/post/6844903958624878606" target="_blank" rel="noopener">https://juejin.im/post/6844903958624878606</a></p>
<h4 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a><strong>2.1 三次握手</strong></h4><p><img src="https://pics1.baidu.com/feed/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg?token=c86d4509157378798ebbccbe843486d1&s=9746F8123F5754CA48D574DA0300D0B2" alt="pic"></p>
<h4 id="2-2-四次挥手"><a href="#2-2-四次挥手" class="headerlink" title="2.2 四次挥手"></a><strong>2.2 四次挥手</strong></h4><p><img src="https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073" alt="pic"></p>
<h4 id="2-3-拥塞控制"><a href="#2-3-拥塞控制" class="headerlink" title="2.3 拥塞控制"></a><strong>2.3 拥塞控制</strong></h4><ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<h4 id="2-4-流量控制"><a href="#2-4-流量控制" class="headerlink" title="2.4 流量控制"></a><strong>2.4 流量控制</strong></h4><h4 id="2-5-为什么等待2MSL"><a href="#2-5-为什么等待2MSL" class="headerlink" title="2.5 为什么等待2MSL"></a><strong>2.5 为什么等待2MSL</strong></h4><p>​        因为服务器端在选择断开连接时，会发送报文给客户端，然后客户端收到信息后要发送给服务器端我已经知道你要断开，但可能这个客户端发送的信息在网络过程中断掉了，服务器端没有收到，当服务器端在1个MSL没有收到后，会继续发给客户端我要断掉联系的请求，所以TCP的客户端需要等待2MSL以防止没有真正断掉。<strong>在linux中2MSL是2min。FIN是1min。</strong></p>
<h4 id="2-6-time-wait过多怎么解决？"><a href="#2-6-time-wait过多怎么解决？" class="headerlink" title="2.6 time_wait过多怎么解决？"></a><strong>2.6 time_wait过多怎么解决？</strong></h4><p>​    修改内核参数，包括开启SYN cookie，可防范少量SYN攻击；开启TCP连接中TIME-WAIT sockets的快速回收。开启重用，允许将TIME-WAIT sockets重新用于新的TCP连接。</p>
<h4 id="2-7-有很多的close-wait怎么解决？"><a href="#2-7-有很多的close-wait怎么解决？" class="headerlink" title="2.7 有很多的close_wait怎么解决？"></a><strong>2.7 有很多的close_wait怎么解决？</strong></h4><p>设置线程超时自动回收。出现close_wait基本上就是出bug了。</p>
<h4 id="2-8-为什么要进行第三次握手？"><a href="#2-8-为什么要进行第三次握手？" class="headerlink" title="2.8 为什么要进行第三次握手？"></a><strong>2.8 为什么要进行第三次握手？</strong></h4><p>​    为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>​    如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，</p>
<p>​    还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。</p>
<h4 id="2-9-半连接队列和全连接队列"><a href="#2-9-半连接队列和全连接队列" class="headerlink" title="2.9 半连接队列和全连接队列"></a><strong>2.9 半连接队列和全连接队列</strong></h4><p>​    服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个<strong>队列</strong>里，我们把这种队列称之为<strong>半连接队列</strong>。</p>
<p>​    已经完成三次握手，建立起连接的就会放在<strong>全连接队列</strong>中。如果队列满了就有可能会出现丢包现象。</p>
<h3 id="3-http协议（80端口）"><a href="#3-http协议（80端口）" class="headerlink" title="3.http协议（80端口）"></a>3.http协议（80端口）</h3><h4 id="3-1-返回码"><a href="#3-1-返回码" class="headerlink" title="3.1 返回码"></a><strong>3.1 返回码</strong></h4><p>​    1xx：请求已经被服务器接收，继续处理</p>
<p>​    2xx：成功，请求已经被服务器接收、理解并接收</p>
<p>​    3xx：重定向，需要进行后续操作才能完成这一操作</p>
<p>​    4xx：请求含词法错误或无法正确被执行。403：拒绝提供服务；404无法找到指定位置的资源；400请求出现语法错误。</p>
<p>​    5xx:    请求了正确的服务器，但服务器处理出错</p>
<h4 id="3-2-输入一个网址的全过程"><a href="#3-2-输入一个网址的全过程" class="headerlink" title="3.2 输入一个网址的全过程"></a><strong>3.2 输入一个网址的全过程</strong></h4><ol>
<li>浏览器查找对应的IP地址（递归进行DNS）；</li>
<li>浏览器根据查询到的IP地址向web服务器发送http请求，建立TCP连接；</li>
<li>服务器收到请求并处理；</li>
<li>服务器返回响应；</li>
<li>浏览器对返回的结果进行解析，渲染显示；</li>
<li>页面显示完成后，浏览器发送异步请求请求其他数据。</li>
</ol>
<h4 id="3-3-http2-0-1-1-1-0区别"><a href="#3-3-http2-0-1-1-1-0区别" class="headerlink" title="3.3 http2.0/1.1/1.0区别"></a><strong>3.3 http2.0/1.1/1.0区别</strong></h4><ul>
<li>http1.0: <strong>连接无法复用</strong>，<strong>head of line blocking</strong>（队头阻塞）两个问题，队头阻塞是由于首个packet由于它的目的端口忙而被延迟转发，导致后面的packet被阻塞。</li>
<li>http1.1：默认为<strong>带流水线的持久连接</strong>，而且客户端可以不等数据回来就发送下一个请求。</li>
<li>http2.0： <strong>多路复用</strong>、<strong>二进制分帧</strong>、<strong>服务器推送（主动推送客户端需要的资源，比如CSS，JS）、首部压缩（之前的头部太大，cookie太长）、https</strong>、<strong>stream优先级</strong>（不同的重要性不同，可能还会存在依赖）。<ul>
<li>首部压缩采用的是HPACK编码，有四种方法，动态表（未出现的header），静态表（常用的61个header），静态Huffman，整数编码（整数有自己的编码方式）。</li>
</ul>
</li>
</ul>
<p><strong>Chrome下最多只能有6个TCP连接。</strong></p>
<h4 id="3-4-get和post请求区别"><a href="#3-4-get和post请求区别" class="headerlink" title="3.4 get和post请求区别"></a><strong>3.4 get和post请求区别</strong></h4><ul>
<li>get回退无害，post回退会再次提交请求；</li>
<li>get请求会被浏览器主动cache，post不会；</li>
<li>get请求参数会被完整保存到浏览器历史记录中，而post不会；</li>
<li>get请求URL中传送参数有长度限制，post参数无长度限制；</li>
<li>get没有post安全，直接暴露在URL上；</li>
<li>get只支持ASCII字符，post无限制。</li>
<li>get请求在URL上传递，post在请求主体中。</li>
</ul>
<h4 id="3-5-其他的http请求"><a href="#3-5-其他的http请求" class="headerlink" title="3.5 其他的http请求"></a><strong>3.5 其他的http请求</strong></h4><ul>
<li>options：使服务器传回该资源支持的所有方法；</li>
<li>head：和get一样向服务器发送指定资源的请求，但服务器不返回资源的文本部分。使用该选项，不必传输全部内容就可以获取关于该资源的信息。</li>
<li>put：向指定资源上传最新的内容。</li>
<li>delete：请求服务器删除request的URI所标识的资源；</li>
<li>trace：回显服务器收到的请求，主要用于调试诊断；</li>
<li>connect：http1.1中预留给能够将连接改为管道方式的代理服务器，通常用于SSL加密服务器的连接。</li>
</ul>
<h4 id="3-6-跨域的http请求是什么样的过程？"><a href="#3-6-跨域的http请求是什么样的过程？" class="headerlink" title="3.6 跨域的http请求是什么样的过程？"></a><strong>3.6 跨域的http请求是什么样的过程？</strong></h4><p>​        跨域的http请求：在网络层，要是再一个内网可以直接发送，如果不是还要查询路由表寻找路由，或者默认网关，路由器收到数据后，再次为远程主机或网络查询路由，超过最大跳数就丢包。如果进入外网，会有NAT转换，改成路由器的公网IP。ARP协议获取MAC地址，将IP地址映射成MAC地址，可以将其划为网络层。BGP外部网关协议来控制路由的传播和选择最佳路由。数据链路层MAC寻址。</p>
<h4 id="3-7-http的强缓存和协商缓存"><a href="#3-7-http的强缓存和协商缓存" class="headerlink" title="3.7 http的强缓存和协商缓存"></a>3.7 http的强缓存和协商缓存</h4><h5 id="3-7-1-区别："><a href="#3-7-1-区别：" class="headerlink" title="3.7.1 区别："></a>3.7.1 区别：</h5><ul>
<li>强缓存：直接从本地副本比对读取，<strong>不去请求服务器</strong>，返回的状态码是 <strong>200</strong>。</li>
<li>协商缓存：<strong>会去服务器比对</strong>，若没改变才直接读取本地缓存，返回的状态码是 <strong>304</strong>。</li>
</ul>
<h5 id="3-7-2-强缓存"><a href="#3-7-2-强缓存" class="headerlink" title="3.7.2 强缓存"></a>3.7.2 强缓存</h5><ul>
<li>expires缓存字段（http1.0）：<strong>表示资源的过期时间</strong>(格林尼治时间)，当再次请求该资源的时候，大于时间戳就过期了，小于时间戳直接使用缓存资源。</li>
<li>cache-control（http1.1）:<strong>表示该资源过了多少秒后失效</strong>。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它<strong>不依赖客户端时间</strong>。<code>cache-control</code> 主要有 <code>max-age</code> 和 <code>s-maxage</code>、<code>public</code> 和 <code>private</code>、<code>no-cache</code> 和 <code>no-store</code> 等值。（分为浏览器缓存和代理服务器缓存）no-cache代表协商缓存，no-store代表不采用缓存。</li>
<li>pragma：他的值有 <code>no-cache</code> 和 <code>no-store</code>，表示意思同 <code>cache-control</code>，优先级高于 <code>cache-control</code> 和 <code>expires</code>。</li>
</ul>
<h5 id="3-7-3-协商缓存"><a href="#3-7-3-协商缓存" class="headerlink" title="3.7.3 协商缓存"></a>3.7.3 协商缓存</h5><ul>
<li><p>last-modified： <strong>记录资源最后修改的时间</strong>。启用后，请求资源之后的响应头会增加一个 <code>last-modified</code> 字段。当再次请求该资源时，请求头中会带有 <code>if-modified-since</code> 字段，值是之前返回的 <code>last-modified</code> 的值。服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 <code>last-modified</code> 为新的值。</p>
<ul>
<li><p>缺点：只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应，而这正是缓存本来的作用即避免没必要的请求。</p>
<p>时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。</p>
</li>
</ul>
</li>
<li><p>etag：基于资源的内容编码生成一串<strong>唯一的标识字符串</strong>，只要内容不同，就会生成不同的 <code>etag</code>。启用 <code>etag</code> 之后，请求资源后的响应返回会增加一个 <code>etag</code> 字段。<strong>但每次生成标识字符串会增加服务器的开销。</strong></p>
</li>
</ul>
<h5 id="3-7-4-访问刷新分析"><a href="#3-7-4-访问刷新分析" class="headerlink" title="3.7.4 访问刷新分析"></a>3.7.4 访问刷新分析</h5><ul>
<li>标签进入，输入URL进入：走强缓存路线。若强缓存过期，采用协商缓存，若协商缓存过期，直接返回最新的资源，并更新last-modified。</li>
<li>按刷新按钮、F5刷新、网页右键“重新加载”：走协商缓存路线，将cache-control的max-age设置为0；</li>
<li>ctrl+F5强制刷新：不采用缓存策略，直接设置为no-cache，强制访问最新资源。</li>
</ul>
<h4 id="3-8-使用HTTP长链接有哪些优点？"><a href="#3-8-使用HTTP长链接有哪些优点？" class="headerlink" title="3.8 使用HTTP长链接有哪些优点？"></a>3.8 使用HTTP长链接有哪些优点？</h4><ul>
<li>减少握手次数</li>
<li>减少慢启动的影响（每次连接都要通过慢启动达到一个合适的收发速率）。</li>
<li>缺点：TCP是字符流协议，顺序不能乱，在一个长链接上发送多个请求，就是串行的，串行就会会产生队头阻塞。</li>
</ul>
<h3 id="4-Https（443端口）"><a href="#4-Https（443端口）" class="headerlink" title="4.Https（443端口）"></a>4.Https（443端口）</h3><h4 id="4-1https建立连接流程"><a href="#4-1https建立连接流程" class="headerlink" title="4.1https建立连接流程"></a><strong>4.1https建立连接流程</strong></h4><ol>
<li><p>浏览器将自己支持的一套加密规则发送给网站。</p>
</li>
<li><p>服务器端从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p>
</li>
<li><p>客户端验证证书的合法性，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p>
</li>
<li><p>服务器端使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 使用密码加密一段握手消息，发送给浏览器。</p>
</li>
<li><p>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p>
<p>HASH算法是为了验证数据的完整性。浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据。</p>
</li>
</ol>
<h4 id="4-2-https如何做到安全连接"><a href="#4-2-https如何做到安全连接" class="headerlink" title="4.2 https如何做到安全连接"></a><strong>4.2 https如何做到安全连接</strong></h4><p>​    对称加密和非对称加密。</p>
<h3 id="5-DNS"><a href="#5-DNS" class="headerlink" title="5.DNS"></a>5.DNS</h3><p>采用的是UDP协议。</p>
<p>DNS解析方法分为本地解析和集中式域名解析：</p>
<ul>
<li>本地解析：在客户端维护一个静态文件</li>
<li>集中式域名解析：在DNS服务器上递归解析。    </li>
</ul>
<h3 id="6-ping"><a href="#6-ping" class="headerlink" title="6.ping"></a>6.ping</h3><p>​        采用ICMP协议，位于网络层，而端口号信息位于传输层，因此没有端口号；此外ICMP采用IP协议发送，因此是一种尽力而为的传输。</p>
<h3 id="7-TCP与UDP优缺点和区别"><a href="#7-TCP与UDP优缺点和区别" class="headerlink" title="7.TCP与UDP优缺点和区别"></a>7.TCP与UDP优缺点和区别</h3><ul>
<li>TCP<ul>
<li>优点：可靠、稳定。</li>
<li>缺点：慢、效率低、占用系统资源高，易被攻击（DOS、DDOS等）。</li>
</ul>
</li>
<li>UDP<ul>
<li>优点：快，比TCP稍安全</li>
<li>缺点：不可靠、 不稳定</li>
</ul>
</li>
<li>TCP和UDP的区别：<ul>
<li>TCP面向连接、UDP无连接；</li>
<li>TCP可靠传输、UDP不可靠</li>
<li>TCP面向字节流、UDP面向数据报</li>
<li>TCP保证数据顺序、UDP不保证</li>
</ul>
</li>
</ul>
<h3 id="8-NAT是什么？底层怎么实现的？"><a href="#8-NAT是什么？底层怎么实现的？" class="headerlink" title="8.NAT是什么？底层怎么实现的？"></a>8.NAT是什么？底层怎么实现的？</h3><p>​    NAT是网络地址转换协议，有助于减缓IP地址枯竭，有效避免来自网络外部的攻击，隐藏并保护网络内部计算机。（带宽分享，安全防护）</p>
<p>​    实现方式（三种）：</p>
<ul>
<li>静态转换：IP地址一对一</li>
<li>动态转换：IP地址不确定</li>
<li>端口多路复用：采用的最多，改变外出数据包的源端口并进行端口转换，即端口地址转换。</li>
</ul>
<h3 id="9-能介绍一下多播是怎么实现的吗？"><a href="#9-能介绍一下多播是怎么实现的吗？" class="headerlink" title="9.能介绍一下多播是怎么实现的吗？"></a>9.能介绍一下多播是怎么实现的吗？</h3><ul>
<li>多播目前在局域网使用的多。ARP攻击就是多播。</li>
<li>多播分为广播和组播。<ul>
<li>广播和多播好处：对发送端性能提升很大，对带宽使用更少。</li>
<li>MAC地址全1就是广播。</li>
</ul>
</li>
</ul>
<h3 id="10-服务器的最大并发连接数是多少？"><a href="#10-服务器的最大并发连接数是多少？" class="headerlink" title="10.服务器的最大并发连接数是多少？"></a>10.服务器的最大并发连接数是多少？</h3><p>​        2^48</p>
<h3 id="11-如何实现高并发？"><a href="#11-如何实现高并发？" class="headerlink" title="11.如何实现高并发？"></a>11.如何实现高并发？</h3><p>​    处理一个请求的粒度特别小，不要太长</p>
<h3 id="12-linux下的高并发优化？"><a href="#12-linux下的高并发优化？" class="headerlink" title="12.linux下的高并发优化？"></a>12.linux下的高并发优化？</h3><h2 id="八、Linux"><a href="#八、Linux" class="headerlink" title="八、Linux"></a>八、Linux</h2><h3 id="1-常用的操作命令"><a href="#1-常用的操作命令" class="headerlink" title="1.常用的操作命令"></a>1.常用的操作命令</h3><h4 id="1-1查看端口（netstat）"><a href="#1-1查看端口（netstat）" class="headerlink" title="1.1查看端口（netstat）"></a>1.1查看端口（netstat）</h4><p>netstat  -tunlp |grep port:查看指定端口号进程情况，可以看到本地地址，外部地址，采用的协议，端口状态（listen），进程的PID。</p>
<h4 id="1-2查看进程（top）"><a href="#1-2查看进程（top）" class="headerlink" title="1.2查看进程（top）"></a>1.2查看进程（top）</h4><p>可以看到PID，进程所有者，进程优先级，虚拟内存，常驻内存，共享内存大小（kb），进程的状态（D：不可中断的睡眠状态，R运行，S睡眠，T跟踪/停止，Z僵尸进程），进程的使用CPU时间，进程使用的物理内存、进程的名称（命令行/命令名)</p>
<h3 id="2-Linux进程地址空间的布局"><a href="#2-Linux进程地址空间的布局" class="headerlink" title="2.Linux进程地址空间的布局"></a>2.Linux进程地址空间的布局</h3><p>​    虚拟内存、分页、页表</p>
<h3 id="3-linux内核架构"><a href="#3-linux内核架构" class="headerlink" title="3.linux内核架构"></a>3.linux内核架构</h3><p><img src="C:%5CUsers%5C84355%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598001918577.png" alt="1598001918577"></p>
<p>4.写时复制原理？</p>
<p>只有在修改（写）的时候，才会进程分离</p>
<p><img src="C:%5CUsers%5C84355%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1598002280675.png" alt="1598002280675"></p>
<h2 id="九、项目"><a href="#九、项目" class="headerlink" title="九、项目"></a>九、项目</h2><h3 id="1-ROS项目"><a href="#1-ROS项目" class="headerlink" title="1.ROS项目"></a>1.ROS项目</h3><h3 id="2-JavaWeb项目"><a href="#2-JavaWeb项目" class="headerlink" title="2.JavaWeb项目"></a>2.JavaWeb项目</h3><h3 id="3-Android项目"><a href="#3-Android项目" class="headerlink" title="3.Android项目"></a>3.Android项目</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/10/数据结构与算法面经/" rel="next" title="数据结构与算法面经">
                <i class="fa fa-chevron-left"></i> 数据结构与算法面经
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/10/秋招进度/" rel="prev" title="秋招进度">
                秋招进度 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NjY3Mi8yMzE4Mg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/pic.jpg" alt="lifisher">
            
              <p class="site-author-name" itemprop="name">lifisher</p>
              <p class="site-description motion-element" itemprop="description">独立有思想，温柔有力量</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.bilibili.com/" title="bilibili" target="_blank">bilibili</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.baidu.com/" title="baidu" target="_blank">baidu</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.yqxpro.com/" title="yqx" target="_blank">yqx</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#面试笔记"><span class="nav-text">面试笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、C"><span class="nav-text">一、C++</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-基础知识"><span class="nav-text">1.基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-关键字"><span class="nav-text">1.1 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-static"><span class="nav-text">1.1.1 static</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-const"><span class="nav-text">1.1.2 const</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-sizeof"><span class="nav-text">1.1.3 sizeof</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-auto"><span class="nav-text">1.1.4 auto</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-5-extern"><span class="nav-text">1.1.5 extern</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-类"><span class="nav-text">1.2 类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-创建对象的步骤？"><span class="nav-text">1.2.1 创建对象的步骤？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-类的初始化"><span class="nav-text">1.2.2 类的初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-析构函数可以是虚函数吗？构造函数可以是虚函数吗？"><span class="nav-text">1.2.3 析构函数可以是虚函数吗？构造函数可以是虚函数吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-4-C-的多态是怎么实现的？"><span class="nav-text">1.2.4 C++的多态是怎么实现的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-函数"><span class="nav-text">1.3 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-参数传递"><span class="nav-text">1.3.1 参数传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-函数重载与函数重写的区别？"><span class="nav-text">1.3.2 函数重载与函数重写的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-3-内联函数"><span class="nav-text">1.3.3 内联函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-宏定义函数"><span class="nav-text">1.3.4 宏定义函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-5-宏定义函数和内联函数的区别？"><span class="nav-text">1.3.5 宏定义函数和内联函数的区别？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-指针"><span class="nav-text">1.4 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-1-智能指针"><span class="nav-text">1.4.1 智能指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-2-指针和引用的区别？"><span class="nav-text">1.4.2 指针和引用的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-3-delete-p和delete-p的区别？"><span class="nav-text">1.4.3 delete p和delete[] p的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-4-new、delete和malloc、free的区别？"><span class="nav-text">1.4.4 new、delete和malloc、free的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-5-malloc和mmap的底层实现？malloc分配的是什么？"><span class="nav-text">1.4.5 malloc和mmap的底层实现？malloc分配的是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-6-什么是内存泄露？"><span class="nav-text">1.4.6 什么是内存泄露？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-7-什么是野指针？"><span class="nav-text">1.4.7 什么是野指针？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-8常见的动态内存泄露？"><span class="nav-text">1.4.8常见的动态内存泄露？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-move（）和forward（）"><span class="nav-text">1.5 move（）和forward（）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-左值引用和右值引用"><span class="nav-text">1.6 左值引用和右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-1-左值和右值的区分？"><span class="nav-text">1.6.1 左值和右值的区分？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-2-为什么要进行右值引用？"><span class="nav-text">1.6.2 为什么要进行右值引用？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-union"><span class="nav-text">1.7 union</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-1-什么是union？"><span class="nav-text">1.7.1 什么是union？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-2-union和struct区别？"><span class="nav-text">1.7.2 union和struct区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-3-union需要注意的？"><span class="nav-text">1.7.3 union需要注意的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-强制转换"><span class="nav-text">1.8 强制转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-容器类库"><span class="nav-text">2.容器类库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-线程库"><span class="nav-text">3.线程库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-内存管理（堆栈管理）"><span class="nav-text">4.内存管理（堆栈管理）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1堆栈的区别？"><span class="nav-text">4.1堆栈的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-C-编译成可执行程序的过程"><span class="nav-text">5.C++编译成可执行程序的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-C-11的新特性有哪些？"><span class="nav-text">6.C++11的新特性有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、数据结构"><span class="nav-text">二、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-链表"><span class="nav-text">1.链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-有环链表"><span class="nav-text">1.1 有环链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-链表的插入和删除"><span class="nav-text">1.2 链表的插入和删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-链表的逆序"><span class="nav-text">1.3 链表的逆序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-链表的深复制"><span class="nav-text">1.4 链表的深复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-二叉树"><span class="nav-text">2.二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1完全二叉树的存储"><span class="nav-text">2.1完全二叉树的存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-哈夫曼树"><span class="nav-text">2.2 哈夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-满二叉树"><span class="nav-text">2.3 满二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-树的前序遍历"><span class="nav-text">2.4 树的前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-树的中序遍历"><span class="nav-text">2.5 树的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-树的后序遍历"><span class="nav-text">2.6 树的后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-树的层序遍历"><span class="nav-text">2.7 树的层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-树的深度和广度"><span class="nav-text">2.8 树的深度和广度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-红黑树"><span class="nav-text">2.9 红黑树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-哈希表"><span class="nav-text">3.哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-哈希表怎么解决冲突？"><span class="nav-text">3.1 哈希表怎么解决冲突？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-图"><span class="nav-text">4.图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1最小生成树算法"><span class="nav-text">4.1最小生成树算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-最短路径算法"><span class="nav-text">4.2 最短路径算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、算法"><span class="nav-text">三、算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-常用的算法"><span class="nav-text">1.常用的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-排序"><span class="nav-text">2.排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-递归"><span class="nav-text">3.递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-时间复杂度分析"><span class="nav-text">4.时间复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、设计模式"><span class="nav-text">四、设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-常见的设计模式"><span class="nav-text">1.常见的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-单例模式"><span class="nav-text">2.单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-观察者模式"><span class="nav-text">3.观察者模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、数据库（MySQL）"><span class="nav-text">五、数据库（MySQL）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-mysql特点"><span class="nav-text">1.mysql特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-mysql的框架"><span class="nav-text">2.mysql的框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-事务"><span class="nav-text">3.事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-ACID特性"><span class="nav-text">3.1 ACID特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-事务的安全性问题"><span class="nav-text">3.2 事务的安全性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-事务的隔离级别"><span class="nav-text">3.3 事务的隔离级别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-存储引擎"><span class="nav-text">4.存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-InnoDB"><span class="nav-text">4.1 InnoDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-MyISAM"><span class="nav-text">4.2 MyISAM</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-索引"><span class="nav-text">5.索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1索引的定义"><span class="nav-text">5.1索引的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-索引的分类（方法）"><span class="nav-text">5.2 索引的分类（方法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-索引的分类"><span class="nav-text">5.3 索引的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-索引的优势和劣势"><span class="nav-text">5.4 索引的优势和劣势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-B树和B-树"><span class="nav-text">5.5 B树和B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-聚簇索引和非聚簇索引"><span class="nav-text">5.6 聚簇索引和非聚簇索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-锁"><span class="nav-text">6.锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1锁粒度"><span class="nav-text">6.1锁粒度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-锁级别"><span class="nav-text">6.2 锁级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-乐观锁和悲观锁"><span class="nav-text">6.3 乐观锁和悲观锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-视图"><span class="nav-text">7.视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1视图"><span class="nav-text">7.1视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、操作系统"><span class="nav-text">六、操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-进程与线程"><span class="nav-text">1.进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1进程"><span class="nav-text">1.1进程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-1-进程的通信方式"><span class="nav-text">1.1.1 .进程的通信方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-2-进程的定义与特点"><span class="nav-text">1.1.2.进程的定义与特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-3-进程（作业）的调度算法"><span class="nav-text">1.1.3 .进程（作业）的调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-4-进程拥有的资源"><span class="nav-text">1.1.4 .进程拥有的资源</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2线程"><span class="nav-text">1.2线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-线程同步的方式？"><span class="nav-text">1.2.1.线程同步的方式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-2-线程拥有的资源？"><span class="nav-text">1.2.2.线程拥有的资源？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-3-线程的状态？"><span class="nav-text">1.2.3.线程的状态？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3进程与线程的区别？"><span class="nav-text">1.3进程与线程的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-IO多路复用"><span class="nav-text">2.IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-一次IO操作流程"><span class="nav-text">2.1 一次IO操作流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-同步IO"><span class="nav-text">2.2 同步IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-异步IO（使用较少）"><span class="nav-text">2.3 异步IO（使用较少）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-同步IO和异步IO的区别"><span class="nav-text">2.4 同步IO和异步IO的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-阻塞IO和非阻塞IO的区别"><span class="nav-text">2.5 阻塞IO和非阻塞IO的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-IO多路复用（事件驱动IO）"><span class="nav-text">2.6 IO多路复用（事件驱动IO）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-1-select（）和-poll（）"><span class="nav-text">2.6.1 select（）和 poll（）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-3-epoll（）"><span class="nav-text">2.6.3 epoll（）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-内存管理"><span class="nav-text">3.内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1内存管理的方式"><span class="nav-text">3.1内存管理的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2linux内存管理"><span class="nav-text">3.2linux内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-虚拟内存、常驻内存、共享内存"><span class="nav-text">3.3 虚拟内存、常驻内存、共享内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-死锁"><span class="nav-text">4.死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-生产者消费者模型"><span class="nav-text">5.生产者消费者模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、计算机网络"><span class="nav-text">七、计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-七层、五层、四层网络模型"><span class="nav-text">1.七层、五层、四层网络模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TCP-IP协议"><span class="nav-text">2.TCP/IP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-三次握手"><span class="nav-text">2.1 三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-四次挥手"><span class="nav-text">2.2 四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-拥塞控制"><span class="nav-text">2.3 拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-流量控制"><span class="nav-text">2.4 流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-为什么等待2MSL"><span class="nav-text">2.5 为什么等待2MSL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-time-wait过多怎么解决？"><span class="nav-text">2.6 time_wait过多怎么解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-有很多的close-wait怎么解决？"><span class="nav-text">2.7 有很多的close_wait怎么解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-为什么要进行第三次握手？"><span class="nav-text">2.8 为什么要进行第三次握手？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-半连接队列和全连接队列"><span class="nav-text">2.9 半连接队列和全连接队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-http协议（80端口）"><span class="nav-text">3.http协议（80端口）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-返回码"><span class="nav-text">3.1 返回码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-输入一个网址的全过程"><span class="nav-text">3.2 输入一个网址的全过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-http2-0-1-1-1-0区别"><span class="nav-text">3.3 http2.0/1.1/1.0区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-get和post请求区别"><span class="nav-text">3.4 get和post请求区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-其他的http请求"><span class="nav-text">3.5 其他的http请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-跨域的http请求是什么样的过程？"><span class="nav-text">3.6 跨域的http请求是什么样的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-http的强缓存和协商缓存"><span class="nav-text">3.7 http的强缓存和协商缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-1-区别："><span class="nav-text">3.7.1 区别：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-2-强缓存"><span class="nav-text">3.7.2 强缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-3-协商缓存"><span class="nav-text">3.7.3 协商缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-4-访问刷新分析"><span class="nav-text">3.7.4 访问刷新分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-使用HTTP长链接有哪些优点？"><span class="nav-text">3.8 使用HTTP长链接有哪些优点？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Https（443端口）"><span class="nav-text">4.Https（443端口）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1https建立连接流程"><span class="nav-text">4.1https建立连接流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-https如何做到安全连接"><span class="nav-text">4.2 https如何做到安全连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-DNS"><span class="nav-text">5.DNS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ping"><span class="nav-text">6.ping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-TCP与UDP优缺点和区别"><span class="nav-text">7.TCP与UDP优缺点和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-NAT是什么？底层怎么实现的？"><span class="nav-text">8.NAT是什么？底层怎么实现的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-能介绍一下多播是怎么实现的吗？"><span class="nav-text">9.能介绍一下多播是怎么实现的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-服务器的最大并发连接数是多少？"><span class="nav-text">10.服务器的最大并发连接数是多少？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-如何实现高并发？"><span class="nav-text">11.如何实现高并发？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-linux下的高并发优化？"><span class="nav-text">12.linux下的高并发优化？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、Linux"><span class="nav-text">八、Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-常用的操作命令"><span class="nav-text">1.常用的操作命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1查看端口（netstat）"><span class="nav-text">1.1查看端口（netstat）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2查看进程（top）"><span class="nav-text">1.2查看进程（top）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Linux进程地址空间的布局"><span class="nav-text">2.Linux进程地址空间的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-linux内核架构"><span class="nav-text">3.linux内核架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、项目"><span class="nav-text">九、项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ROS项目"><span class="nav-text">1.ROS项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JavaWeb项目"><span class="nav-text">2.JavaWeb项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Android项目"><span class="nav-text">3.Android项目</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lifisher</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">20.7k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("KefaqEODBtBgPGEwQgIKJ6N8-gzGzoHsz", "F22H4lUhcb6M0dCGRhPxmj5T");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  


  

  

</body>
</html>
