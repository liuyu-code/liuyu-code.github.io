<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法面经]]></title>
    <url>%2F2020%2F07%2F10%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[数据结构与算法面经1.Top K解决办法。 全局排序，O(n*lg(n)) 局部排序(冒泡前k个)，只排序前k个,O(n*k); 堆排序，前k个也不用排序了。维护一个k个元素的小顶堆，进入新的元素不断与小顶堆的root比较，最终得到的就是未排序的前k个元素，O(n*lg(k)) 随机选择+partition.通过随机选择，找到arr[1, n]中第k大的数，再进行一次partition，就能得到TopK的结果。 分治法：每个分支都要递归，例如快速排序 快速排序算法思想(分治法:把一个大的问题，转化为若干个子问题（Divide），每个子问题“都”解决，大的问题便随之解决)。 123456void quick_sort(int[]arr, int low, inthigh)&#123; if(low== high) return; int i = partition(arr, low, high);//快速排序的核心,会用数组arr中的一个元素（默认是第一个元素t=arr[low]）为划分依据，将数据arr[low, high]划分成左右两个子数组：左半部分，都比t大;右半部分，都比t小;中间位置i是划分元素 quick_sort(arr, low, i-1); quick_sort(arr, i+1, high);&#125; 减治法：把一个大的问题，转化为若干个子问题（Reduce），这些子问题中“只”解决一个，大的问题便随之解决（Conquer）。只需要递归一个分支解决问题，例如二分查找O(lg(n)),随机选择O(n); 二分查找思想（减治法）： 123456789int BS(int[]arr, int low, inthigh, int target)&#123; if(low&gt; high) return -1; mid= (low+high)/2; if(arr[mid]== target) return mid; if(arr[mid]&gt; target) return BS(arr, low, mid-1, target); else return BS(arr, mid+1, high, target);&#125; 随机选择算法（找出第K大的数）： 在第一次partition后：i = partition(arr, 1, n); 如果i大于k，则说明arr[i]左边的元素都大于k，于是只递归arr[1, i-1]里第k大的元素即可； 如果i小于k，则说明说明第k大的元素在arr[i]的右边，于是只递归arr[i+1, n]里第k-i大的元素即可； 随机选择算法伪代码： 123456789int RS(arr, low, high, k)&#123; if(low== high) return arr[low]; i= partition(arr, low, high); temp= i-low; //数组前半部分元素个数 if(temp&gt;=k) return RS(arr, low, i-1, k); //求前半部分第k大 else return RS(arr, i+1, high, k-i); //求后半部分第k-i大&#125; 2.各种排序算法介绍。详见博客：https://www.cnblogs.com/flyingdreams/p/11161157.html 交换排序： 冒泡排序 快速排序 插入排序： 简单插入排序 希尔排序（缩小增量排序） 选择排序 简单选择排序 堆排序 归并排序 排序方法 时间复杂度（平均） 时间复杂度（最坏) 时间复杂度（最好） 空间复杂度 稳定性 插入排序 O(n^2) O(n) O(1) 稳定 希尔排序 O(n^1.5) O(n^2) O(n) O(1) 不稳定 选择排序 O(n^2) O(1) 不稳定 堆排序 O(nlgn) O(1) 不稳定 冒泡排序 O(n^2) O(n) O(1) 稳定 快速排序 O(nlgn) O(n^2) O(nlgn) 不稳定 归并排序 O(nlgn) O(n) 稳定 注：未写复杂度的和平均是一样的。 选择排序和冒泡的区别：冒泡交换相邻元素，每一次找到最大的；选择排序是直接找到最大的，然后放到已排序的末尾。 快速排序思路：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 123456789101112131415161718192021222324252627282930313233343536void quickSort(vector&lt;int&gt;&amp; arr, int low, int high)&#123; int l = low; int h = high; int base = arr[low]; //选取第一个数为基准 while (l &lt; h) &#123; //从后向前比较 while (l &lt; h &amp;&amp; arr[h] &gt;= base) //如果没有比关键值小的，比较下一个 &#123; h--; &#125; if (l &lt; h) &#123; swap(arr[l], arr[h]); //进行替换后，arr[l]肯定小于base，所以不用再次比较 l++; &#125; //从前向后比较 while (l &lt; h &amp;&amp; arr[l] &lt;= base) &#123; l++; &#125; if (l &lt; h) &#123; swap(arr[l], arr[h]); h--; &#125; &#125; //此时第一次比较已经结束，关键值位置已经确定为l(l=h)，左边都比关键值小，右边都比关键值大 //递归 if (l &gt; low) quickSort(arr, low, l - 1); if (l &lt; high) quickSort(arr, l + 1, high);&#125; 归并排序思路：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。它使用了递归分治的思想；相当于：左半边用尽，则取右半边元素；右半边用尽，则取左半边元素；右半边的当前元素小于左半边的当前元素，则取右半边元素；右半边的当前元素大于左半边的当前元素，则取左半边的元素。 1234567891011121314151617181920212223private static void mergeSort(int[] array) &#123; int[] aux = new int[array.length]; sort(array, aux, 0, array.length - 1); &#125; private static void sort(int[] array, int[] aux, int lo, int hi) &#123; if (hi&lt;=lo) return; int mid = lo + (hi - lo)/2; sort(array, aux, lo, mid); sort(array, aux, mid + 1, hi); merge(array, aux, lo, mid, hi); &#125; private static void merge(int[] array, int[] aux, int lo, int mid, int hi) &#123; System.arraycopy(array,0,aux,0,array.length); int i = lo, j = mid + 1; for (int k = lo; k &lt;= hi; k++) &#123; if (i&gt;mid) array[k] = aux[j++]; else if (j &gt; hi) array[k] = aux[i++]; else if (aux[j]&lt;aux[i]) array[k] = aux[j++]; else array[k] = aux[i++]; &#125; &#125;]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC模式]]></title>
    <url>%2F2020%2F07%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-MVC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVC模式1.MVC模式即model-view-controller(模型-视图-控制器)模式，常见的比如Android开发中的，view即Android的界面，model即界面上要展示的数据，而controller就是控制数据，数据变化时实时更新view展示的数据。 Model（模型）：代表了一个存取的数据的对象。 View（视图）：视图代表了模型包含的数据的可视化。 Controller（控制器）：控制器作用于模型和视图之上，可以做到在数据变化时实时更新视图。它让model和view分开。 2.实现重点：首先会有一个view类和model类，然后会有一个Controller类，里面包含了一个model对象和view对象，通过Controller实现了view和model的绑定。具体代码： model： 12345678910111213141516public class Student &#123; private String rollNo; private String name; public String getRollNo() &#123; return rollNo; &#125; public void setRollNo(String rollNo) &#123; this.rollNo = rollNo; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; view： 1234567public class StudentView &#123; public void printStudentDetails(String studentName, String studentRollNo)&#123; System.out.println("Student: "); System.out.println("Name: " + studentName); System.out.println("Roll No: " + studentRollNo); &#125;&#125; Controller： 1234567891011121314151617181920212223242526272829public class StudentController &#123; private Student model; private StudentView view; public StudentController(Student model, StudentView view)&#123; this.model = model; this.view = view; &#125; public void setStudentName(String name)&#123; model.setName(name); &#125; public String getStudentName()&#123; return model.getName(); &#125; public void setStudentRollNo(String rollNo)&#123; model.setRollNo(rollNo); &#125; public String getStudentRollNo()&#123; return model.getRollNo(); &#125; public void updateView()&#123; view.printStudentDetails(model.getName(), model.getRollNo()); &#125; &#125; Main： 1234567891011121314151617181920212223242526public class MVCPatternDemo &#123; public static void main(String[] args) &#123; //从数据库获取学生记录 Student model = retrieveStudentFromDatabase(); //创建一个视图：把学生详细信息输出到控制台 StudentView view = new StudentView(); StudentController controller = new StudentController(model, view); controller.updateView(); //更新模型数据 controller.setStudentName("John"); controller.updateView(); &#125; private static Student retrieveStudentFromDatabase()&#123; Student student = new Student(); student.setName("Robert"); student.setRollNo("10"); return student; &#125;&#125; 1234567输出：Student: Name: RobertRoll No: 10Student: Name: JohnRoll No: 10]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>MVC模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2020%2F07%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式1.适配器模式（Adapter Pattern）属于结构型模式，它结合了两个独立接口的功能。是作为两个不兼容接口的桥梁。比如读卡器可以看做是一个适配器，连接电脑和SD卡。适配器可以将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 2.实现方式：通过继承或者依赖，适配器继承或者依赖已有的对象，实现想要的目标接口。 3.应用场景：比如Java中的jdbc。 4.注意：适配器模式在设计的时候一般不采用，而是用于解决已经部署的项目的问题。过多的使用适配器模式会让系统很凌乱，比如明明调用的是A接口，内部却被适配成了B接口的实现。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式 ， 适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面经汇总]]></title>
    <url>%2F2020%2F07%2F05%2FC-%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[C++面经汇总1.手撕算法：求二叉树两节点的最近祖先。 有一个二叉树，节点只包含左右子节点的指针 struct Node { Node* left; Node* right; } 给定两个节点A和B，找出他们的公共祖父结点。 12345678910111213141516171819/* * 二叉树中求两结点的最近祖先(递归版) * */ public static Node findBtreeLca(Node root,int x,int y)&#123; if(root==null) return null; //左右搜索，两边都有返回根节点 if(root.element==x||root.element==y) return root; Node left=findBtreeLca(root.leftChild, x, y); Node right=findBtreeLca(root.rightChild, x, y); //如果在左边没有找到就一定在右边，继续递归 if(left==null) return right; else if(right==null) return left; return root; &#125; 2.cpp文件变成exe文件经历了哪些阶段？图解： 过程如下： （一）预处理阶段。首先我们会对我们编辑得到的源代码（即扩展名为.c/.cpp文件）通过预处理器进行预处理，这一部分是由我们的编译器帮我们完成的。预处理器做的事情就是将原始源文件中的所有预处理器指令替换为暗示指令的实际库代码。那么什么是预处理指令呢？实际上这些是我们在代码很常见的，如#include和#define指令。之后，生成的文件基本上被取代并获得扩展名为.i文件。 （二）编译器编译阶段。接下来是编译器的处理阶段，这个阶段是把高级语言翻译成低级语言的过程，也负责检查源代码的语法/语法。若发现无误，则会将文件转换为扩展名为.s的文件，即我们所知的汇编代码。 （三）目标文件转换阶段。得到汇编文件之后，要对其进行转换，即该过程是将汇编级语言转换为机器级语言（一般为二进制格式），此时生成的文件就是我们的目标文件，扩展名为.o或.obj。 （四）链接阶段。C++语言支持分离式编译（这里指的编译是指上面（一）至（三）阶段）机制的，该机制允许将程序分割为若干个文件，每个文件可独立编译。那么多个已编译的文件如何合并呢？答案就是在此阶段。该阶段通过链接器将一个或多个目标文件合并到一个可执行文件，即将扩展名为.obj / .o文件转换为扩展名为.exe文件。 注：我们平常所说的“编译”是一个整体，即包括预处理，编译和汇编三个阶段。它在这些步骤中基本上将高级语言转换为机器级语言，并生成单个二进制对象文件。若编译（但不链接）三个单独的文件，则将创建三个作为输出的目标文件。 3.说说C++的智能指针。参考博客：https://blog.csdn.net/k346k346/article/details/81478223 4.谈谈阻塞与非阻塞、同步与异步的理解。 5.进行一次IO操作大致所需要的流程 6.进程和线程之间的区别。多进程和多线程各自使用情况，进程和线程之间的通信方式。 7.TCP四次挥手过程以及所处状态，为什么还要有time_wait。 8.常见的排序算法有哪些？哪些是稳定的，哪些不稳定。 9.网络五层模型，每一层有哪些协议，以及每一层的作用。 10.手撕代码：有序数组旋转后找最小值所在位置、给出一个有环的链表输出环的长度； 11.手撕代码：给出一个链表，每两个节点旋转一次，最后返回旋转后的链表； 12.手撕代码：给定一个存在重复元素的有序数组，以及一个目标数字，利用二分查找法找到该数字首次出现的位置； C++继承和组合？你在实际项目中是怎么使用的？什么情况下使用继承？什么情况下使用组合？ C++构造函数可以是虚函数吗？为什么？ C++析构函数可以是虚函数吗？为什么要将析构函数设置为虚函数？ C++如何实现多态？虚表指针是什么时候被初始化的？实例化一个对象需要那几个阶段？（三个） C++偏特化？ 重载、重写、覆盖？ static关键字的作用？（要全面）怎么实现的？ inline和宏定义的区别？inline是如何实现的？宏定义是如何实现的？ 指针和引用的区别？怎么实现的？ malloc和mmap的底层实现？malloc分配的是什么？（底层详细回答） Linux进程地址空间布局？（这里又问道虚拟内存和分页、页表这些东西） tcp的握手挥手过程？（详细）tcp为什么要连接？tcp建立连接这里你是怎么理解的？ 半连接队列？全连接队列？ tcp流量控制和拥塞控制？ time_wait状态？为什么是2msl？ 有很多close_wait怎么解决？ 阻塞和非阻塞？同步和异步？ 五种IO模型？ select和epoll有什么区别？epoll的LT和ET模式？ udp为什么是不可靠的？bind和connect对于udp的作用是什么？ NAT是什么？底层实现原理？ 斐波那契数列的非递归写法？（写出代码） 共享桌面用你熟悉的任意画图工具画项目架构图？（我用的ProcessOn） 聊项目？ 总共用时两个小时吧，问了很多，有些已经想不起来了。]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2020%2F07%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式1.单例模式属于创建型模式。确保一个类只有单个对象被创建，这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。 注意： 1.单例类只能有一个实例； 2.单例类必须自己创建自己唯一的实例； 3.单例类必须给所有其他对象提供这一个实例。 2.使用条件：当想控制实例的数目的时候。比如一个班只有一个班主任，再比如Windows操作文件的时候必须是唯一实例。 3.优点：在内存只有一个实例，避免了内存的开销（频繁创建和销毁实例） 4.缺点：没有借口，不可继承。 5.关键思想：构造函数私有。 实现方法：1.懒汉式，线程不安全。描述：不支持多线程。 123456789public class SingleObject&#123; private static SingleObject object; private SingleObject()&#123;&#125; public static SingleObject getObject()&#123; if(object==null) object=new SingleObject(); return object; &#125;&#125; 2.懒汉式，线程安全。描述：采用synchronize加锁保证单例，支持多线程。加锁影响效率 123456789public class SingleObject&#123; private static SingleObject object; private SingleObject()&#123;&#125; public static synchronize SingleObject getObject()&#123; //采用synchronize if(object==null) object=new SingleObject(); return object; &#125;&#125; 3.饿汉式，线程安全。描述：不用加锁，但类加载时就初始化，会浪费内存。 1234567public class SingleObject&#123; private static SingleObject object=new SingleObject();//和懒汉式区别 private SingleObject()&#123;&#125; public static SingleObject getObject()&#123; return object; &#125;&#125; 4.双重校验锁，线程安全描述：采用双锁机制，在保证线程安全的情况下有较高性能。 123456789101112131415public class SingleObject&#123; private static SingleObject object; private SingleObject()&#123;&#125; public static SingleObject getObject()&#123; if(object==null)&#123; synchronize(SingleObject.class)&#123; if(object==null) &#123; object=new SingleObject(); //存在隐患 &#125; &#125; &#125; return object; &#125;&#125; 在网上查阅发现双重锁还是有隐患，在实例化对象那一行，发生的事情有： A: 分配内存空间 B：初始化对象 C：将对象指向刚分配的空间 但有些编译器可能因为性能原因，BC重排序，会将BC调换顺序，顺序成了ACB。 假设有两个线程A，B： 时间 Thread A Thread B 1 object=null 2 获取锁 3 检查到object=null 4 为object分配内存 5 将object指向内存空间 6 检查到object！=null 7 访问object（此时还未完成初始化） 8 初始化object 修改：在object前加上volatile关键字，重排序被禁止，所有的写操作都发生在读操作之后。 volatile作用：确保本条指令不会因为编译器的优化而省略。表示这个变量可能会意想不到的改变，这样，编译器就不会去假设这个变量的值了。 123456789101112131415public class SingleObject&#123; private static volatile SingleObject object; private SingleObject()&#123;&#125; public static SingleObject getObject()&#123; if(object==null)&#123; synchronize(SingleObject.class)&#123; if(object==null) &#123; object=new SingleObject(); &#125; &#125; &#125; return object; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络面经]]></title>
    <url>%2F2020%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[计算机网络面经1.TCP三次握手和四次挥手过程。详见：https://baijiahao.baidu.com/s?id=1654225744653405133&amp;wfr=spider&amp;for=pc 2.TCP四次分手客户端为什么要等待2MSL（最大报文生存时间？）​ 因为服务器端在选择断开连接时，会发送报文给客户端，然后客户端收到信息后要发送给服务器端我已经知道你要断开，但可能这个客户端发送的信息在网络过程中断掉了，服务器端没有收到，当服务器端在1个MSL没有收到后，会继续发给客户端我要断掉联系的请求，所以TCP的客户端需要等待2MSL以防止没有真正断掉。 3.为什么要进行第三次握手？​ 为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 ​ 如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话， ​ 还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。 3.为什么“握手”是三次，“挥手”却要四次？​ TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。 ​ 即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。 ​ TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。 3.TCP/IP 五层结构，每一层有哪一些网络协议？应用层：HTTP，FTP，TFTP，SMTP，DNS，Telnet 传输层：TCP、UDP 网络层：IP，ICMP，IGMP，RIP 数据链路层：ARP，RARP，CSMA/CD]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沁沁]]></title>
    <url>%2F2019%2F12%2F16%2F%E6%B2%81%E6%B2%81%2F</url>
    <content type="text"><![CDATA[The world is full of traps, but you are the treasure!献给李沁小姐姐！ 我要嫁的人，只有一个条件，要我心里喜欢。 小和尚没化到缘，又路过烧鸭店。 人间不值得！！！]]></content>
      <tags>
        <tag>李沁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表问题总结（相交、成环）]]></title>
    <url>%2F2019%2F09%2F20%2F%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E7%9B%B8%E4%BA%A4%E3%80%81%E6%88%90%E7%8E%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.求链表倒数第K个节点（单向链表）？​ 思路：采用双指针法。P1指向表头，P2指向P1相隔K的节点，同时向后移动，当P2到达表尾(P2-&gt;next=null), P1即倒数第K个节点。 2.判断链表是否有环？​ 首先循环链表是带环链表的一种特殊情况。 ​ 思想：类似于生活中跑步追赶的问题。两个人从相同起点出发，其中一个人的速度比另外一个人快，结果经过一段时间后，速度快的人会追上速度慢的人，此时速度快的人比慢的人多跑了一圈，这样就证明存在了环。 ​ 方法：两个指针P1和P2，从链表的起点开始，P1一次移动一个步长，P2一次移动2个步长，若两个指针相等（并且不等于null），则P2绕了n圈之后追上了P1，则链表存在环。 3.判断两个链表是否存在交点？​ 思想：若L1、L2都无环，直接遍历L1和L2，找到他们的尾节点，若尾节点相同，则必定相交。时间复杂度O（m+n），空间复杂度O（1）。若一个链表有环，一个链表无环，则必不可能相交。若两个都有环，遍历L1环上的每一个节点是否和L2环上的某个节点相等。 4.一个链表成环，环的入口在哪里？​ 设A为起点，B为入口，C为第一次相遇点。且AB=a，BC=x，链表长度为L，环的一圈长度为r。假设相遇时，fast节点走了2s，slow节点走了s。则有 ​$$s+nr=2s\\则有 \ s=nr\\而a+x=s,r=L-a\\则有a+x=(n-1)r+r=(n-1)r+L-a\\则a=(n-1)r+L-a-x。$$​ 而L-a-x为CB的长度（不是BC），则有从链表头A到环入口B等于（n-1）次循环内环加上相遇点到环入口的距离CB，则可让slow节点从A出发，fast节点从C出发。当两者再次相遇的时候就是入口B。（这里可能比较绕，建议大家自己在草稿纸上画一下，就很明显了） 5.如何求单链表中环的长度？​ 思路：仍然采用双指针，一个指针速度为2，一个指针速度为1，则第一次相遇的时候存在：$$2t_1-t_1=kr$$​ 第二次相遇的时候有：$$2t_2-t_2=(k+1)r$$​ 两式相减有：$$t_2-t_1=r$$​ 因此只需要记录第一次相遇时前进的步数t1和第二次相遇前进的步数t2,即可求出环的长度。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构，链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning入门笔记1（吴恩达）]]></title>
    <url>%2F2019%2F09%2F20%2FMachineLearning%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01%EF%BC%88%E5%90%B4%E6%81%A9%E8%BE%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.机器学习算法分类 supervised learning（监督学习） classification problem（分类问题） regression problem（回归问题） unsupervised learning（无监督学习）（clustering algorithm，聚类） 2.supervised learning中的regression problem流程：​ 监督学习首先会有一个原始的训练集Training Set，之后通过你的学习算法Learning Algorithm得到一个预测函数h(x), 这个预测函数可以通过input数据得到一个estimated output。 3.regression problem中的代价函数cost function最小化求解参数：​ 其实这就是一个优化问题，最简单的模型就是线性拟合，和我们初高中学的最小二乘法拟合直线的思想差不多。目的是通过坐标系上一系列已知的点拟合出一条最佳直线，这个直线y=ax+b中的a和b其实就是你需要求解的目标。当你有多个因素影响的时候，方程可能就是y=a0+a1x1+a2x2+…+amxm。这里向量（a0,a1,a2,…am）其实就是在回归问题中需要求解的目标，使得这个线性方程能够最好的拟合这些已知的点，然后利用这个求得的方程去预测之后的结果。 3.1 两种求解参数的方法：梯度下降法求解参数的递推公式如下，$$\theta_j :=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_\theta(x^(i)-y^(i)x_j^(i) （\theta_j代表从0更新到n）$$​ 在实际应用中可以采用特征缩放（feature scaling）对x_i进行处理可以让梯度下降的更快，也可以采用均值归一化进行特征处理。 正规方程组求解参数（可以一步得到）：$$\theta=(X^TX)^-1 X^Ty$$​ 正规方程组求解可以不进行特征缩放。 3.2梯度下降法和正规方程组求解方法的区别梯度下降法（Gradient descent）：需要选择一个相对最佳的下降率alpha；需要多次迭代；但可以在特征向量很多的时候工作的很好，适用于多特征的问题。 正规方程组方法(Normal equation)：不需要选择下降率，也不需要迭代，只需要计算一个矩阵的转置和矩阵相乘的逆，时间复杂度大概是O(n^3)，当特征数量太大之后计算特别慢，适合处理小特征的问题。]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo个人博客搭建之next主题插件总结]]></title>
    <url>%2F2019%2F09%2F18%2Fgithub-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAnext%E4%B8%BB%E9%A2%98%E6%8F%92%E4%BB%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ 前言：在完成博客搭建之后，之前使用的github+hexo的一套采用的是yilla主题，但之后在网上查阅后发现其实next主题更加符合我的口味，而且它是一款国人开发的针对中国的github博客主题，并且拥有很多第三方插件的接口，在这里我把我当时参考更换主题和引入第三方插件的网站做一个统计分享。 1.这个是next主题下载安装使用的官方操作： http://theme-next.iissnan.com/getting-started.html 2.这个是Next主题的官方使用文档，里面详细介绍了第三方服务的集成。 http://theme-next.iissnan.com/third-party-services.html#algolia-search 3.这个网站是next官方推荐的为Next主题添加文章阅读量统计功能的博客。 https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud 4.这个是hexo中Next主题的详细配置。 https://www.jianshu.com/p/3a05351a37dc ​ 访问量的统计我采用的是leancloud，评论系统采用的是来必力的。此外推荐一个免费使用的图床网站https://www.picb.cc/，还不太清楚有没有限制，但暂时使用我没有发现任何问题。]]></content>
      <categories>
        <category>github博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github+hexo搭建个人博客]]></title>
    <url>%2F2019%2F09%2F17%2Fgithub-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1.搭建前的准备工作 有一个github的账号 安装了git for windows 安装node.js、npm ​ 这些软件直接安装最新版的就可以。 2.创建仓库​ 在github上创建一个名为username.github.io的仓库，其中username就是你的github上的用户名。当搭建步骤完成之后你就可以直接访问 https://username.github.io 来访问你的博客了。 3.配置SSH key​ 因为提交代码的时候需要拥有github上的权限，因此需要采用ssh key解决本地和服务器之间的连接问题。在git bash（一个在Windows下使用linux命令行的terminal）上先检查本机是否已经存在的ssh key。 1$ cd ~/.ssh ​ 若提示：No such file or directory 说明这是你第一次使用git。 1$ ssh-keygen -t rsa -C &quot;邮件地址&quot; ​ 输入命令后需要三次回车，最终会在你的电脑的用户目录下生成一个文件夹，找到.ssh/id_rsa.pub文件，用记事本打开后复制里面的内容，然后打开你的github主页，进入个人设置中的SSH and GPG keys，在New SSH key中填写一个title，然后将复制的SSH key粘贴到key那里就可以了。 ​ 然后在git bash上： 1$ ssh -T git@github.com ​ 当提示Are you sure you want to continue connecting (yes/no)?，输入yes就会看到Hi username！巴拉巴拉的，说明你已经配置成功了SSH。 ​ 之后还需要再配置一下name和email。 12$ git config --global user.name &quot;username&quot; //这里引号中的是你的github的name$ git config --global user.email &quot;xxx@163.com&quot; //这里引号中是你之前绑定的邮箱 4.使用hexo写博客​ hexo是一个简单、快速、强大的基于Github Pages的博客发布工具，支持Markdown，有许多优秀的插件和主题。 4.1 安装​ 在git bash上： 1$ npm install -g hexo 4.2 创建hexo工作空间​ 在你的磁盘上创建一个hexo文件夹（名字随意），这个文件夹就是将来写博客和存放代码的地方，因此最好选定好位置（我的是f盘上的hexo-github文件夹）。然后在git bash上： 12$ cd /f/hexo-github/$ hexo init ​ hexo会自动下载文件到这个目录中，里面包括了source，theme等文件。然后在git bash上： 12$ hexo g #genereat，这个类似编译生成$ hexo s #server,启动本地服务，开启后可以访问http://localhost:4000，就可以看到博客界面 4.3 修改主题​ 官方的默认主题比较丑，因此可以换一个主题，我选择是hexo-theme-yilia。下载这个主题： 12$ cd /f/hexo-github/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia ​ 主题下载后在themes下，之后修改hexo-github下（不是你下载的主题下）的_config.yml，将里面的theme: landscape 改为 theme: yilia。需要注意这里属性的修改在冒号后面都是有空格的，很多时候达不到你想要的效果就是因为这个原因，查看一下是否忘记空格了。修改完之后直接执行hexo g重新生成。要是还有一些问题，可以先clean一下，使用 hexo clean命令，然后重新生成和发布。 4.4 上传到github​ 之前都是部署在本地，现在需要将自己的博客上传到外网，即github上。首先要进行一些上传前的配置。 ​ 首先安装一个插件： 1$ npm install hexo-deployer-git ​ 然后在hexo-github文件夹下配置_config.yml中有关deploy部分： 1234deploy: type: git repository: git@github.com:liuyu-code/liuyu-code.github.io.git branch: master ​ 之后你就可以使用hexo d将所有有改动的部分提交到github上。 5.常见hexo命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 ​ 缩写： 1234hexo n == hexo new #后者等价于前者hexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy ​ 组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 6.写博客​ 首先定位到hexo的工作根目录，在git bash中执行命令： 1hexo new &apos;my_first_blog&apos; ​ hexo会在_posts下生成相关md文件，只需要我们打开这个文件就可以开始写博客了，写博客需要掌握一些markdown的基本语法规则，一开始我采用的Notepad++这个软件来写的，后来发现一个更好用的博客编辑工具Typora，相比记事本来说，实在是鸟枪换炮了，这个软件真的好用，强烈推荐。]]></content>
      <categories>
        <category>github博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my-first-blog]]></title>
    <url>%2F2019%2F09%2F12%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[github搭建博客的好处介绍使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等； 这是我第一个博客，没有什么营养，作为一个纪念吧。]]></content>
      <tags>
        <tag>github pages</tag>
      </tags>
  </entry>
</search>
